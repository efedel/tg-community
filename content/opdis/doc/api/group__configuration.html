<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Opdis Disassembly Library: Configuration</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Configuration</h1>
<p>API for opdis configuration.  
<a href="#_details">More...</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopdis__info__t.html">opdis_info_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An opdis disassembler.  <a href="structopdis__info__t.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__configuration.html#ga37d4f948fc2b9ece769ebcf1bd49e0df">OPDIS_HANDLER</a> )(const <a class="el" href="structopdis__insn__t.html">opdis_insn_t</a> *i, void *arg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Callback used to determine if disassembly should continue.  <a href="#ga37d4f948fc2b9ece769ebcf1bd49e0df"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__configuration.html#ga173e7d27078a821bd3201a01f70cfba0">OPDIS_DISPLAY</a> )(const <a class="el" href="structopdis__insn__t.html">opdis_insn_t</a> *i, void *arg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Callback used to display or store a disassembled instruction.  <a href="#ga173e7d27078a821bd3201a01f70cfba0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__configuration.html#gaa815fec2e1e52adb3176ec4ebda45920">OPDIS_DECODER</a> )(const <a class="el" href="structopdis__insn__buffer__t.html">opdis_insn_buf_t</a> in, <a class="el" href="structopdis__insn__t.html">opdis_insn_t</a> *out, const <a class="el" href="group__types.html#gaaf912ec32cb076f2f5b8f5d23176b386">opdis_byte_t</a> *buf, <a class="el" href="types_8h.html#abd14f9464752cb16147541a663f70797">opdis_off_t</a> offset, <a class="el" href="group__types.html#ga840b1c720d75ade1aa951917191ab1f8">opdis_vma_t</a> vma, <a class="el" href="types_8h.html#abd14f9464752cb16147541a663f70797">opdis_off_t</a> length, void *arg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Callback used to fill an <a class="el" href="structopdis__insn__t.html" title="Instruction object.">opdis_insn_t</a> from an opdis_insn_buf_t.  <a href="#gaa815fec2e1e52adb3176ec4ebda45920"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__types.html#ga840b1c720d75ade1aa951917191ab1f8">opdis_vma_t</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__configuration.html#gab1bafa0fab6fa510abfcd8e64ca04418">OPDIS_RESOLVER</a> )(const <a class="el" href="structopdis__insn__t.html">opdis_insn_t</a> *i, void *arg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Callback used to convert a branch target to a buffer offset.  <a href="#gab1bafa0fab6fa510abfcd8e64ca04418"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__configuration.html#ga74777b55fa160e8eb444b7695e37818b">OPDIS_ERROR</a> )(enum <a class="el" href="group__disassembly.html#gae90f684a09c4afb4d2189ad97fce7095">opdis_error_t</a> error, const char *msg, void *arg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Callback used to handle error messages.  <a href="#ga74777b55fa160e8eb444b7695e37818b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga38db2ae554cc6fb7bc2f1467d4ae4c61"></a><!-- doxytag: member="configuration::opdis_t" ref="ga38db2ae554cc6fb7bc2f1467d4ae4c61" args="" -->
typedef <a class="el" href="structopdis__info__t.html">opdis_info_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__configuration.html#ga38db2ae554cc6fb7bc2f1467d4ae4c61">opdis_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Disassembler handle (pointer to <a class="el" href="structopdis__info__t.html" title="An opdis disassembler.">opdis_info_t</a>). <br/></td></tr>
<tr><td colspan="2"><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__configuration.html#ga3a5299b15960a05e1f75f5dfb9726b9f">opdis_x86_syntax_t</a> { <a class="el" href="group__configuration.html#ga3a5299b15960a05e1f75f5dfb9726b9fa1351837bb18eb975ea5b72a01e8ca903">opdis_x86_syntax_intel</a>, 
<a class="el" href="group__configuration.html#ga3a5299b15960a05e1f75f5dfb9726b9fa247fb272b325eb12e47a02c7f77e95d1">opdis_x86_syntax_att</a>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Syntax options for x86 disassembly. </p>
 <a href="group__configuration.html#ga3a5299b15960a05e1f75f5dfb9726b9f">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__configuration.html#ga3997e64314bfcffd7389ebbd0a667e4c">opdis_default_handler</a> (const <a class="el" href="structopdis__insn__t.html">opdis_insn_t</a> *insn, void *arg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The built-in opdis handler callback. The default handler returns true unless the instruction is invalid or if the address has already been visited.  <a href="#ga3997e64314bfcffd7389ebbd0a667e4c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__configuration.html#ga08732c2cdf9e14f533cbb48b6f98228f">opdis_default_display</a> (const <a class="el" href="structopdis__insn__t.html">opdis_insn_t</a> *i, void *arg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The built-in opdis display callback This callback writes the instruction <em>ascii</em> field to STDOUT.  <a href="#ga08732c2cdf9e14f533cbb48b6f98228f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__configuration.html#gab14a31bd82821fecdb9c6b1f38e73fa4">opdis_default_decoder</a> (const <a class="el" href="structopdis__insn__buffer__t.html">opdis_insn_buf_t</a> in, <a class="el" href="structopdis__insn__t.html">opdis_insn_t</a> *out, const <a class="el" href="group__types.html#gaaf912ec32cb076f2f5b8f5d23176b386">opdis_byte_t</a> *buf, <a class="el" href="types_8h.html#abd14f9464752cb16147541a663f70797">opdis_off_t</a> offset, <a class="el" href="group__types.html#ga840b1c720d75ade1aa951917191ab1f8">opdis_vma_t</a> vma, <a class="el" href="types_8h.html#abd14f9464752cb16147541a663f70797">opdis_off_t</a> length, void *arg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The built-in opdis instruction decoder This callback fills the <em>ascii</em>, <em>offset</em>, <em>vma</em>, <em>bytes</em>, and <em>size</em> fields of the output instruction object. It is recommended that all other decoders invoke this callback directly to fill these fields.  <a href="#gab14a31bd82821fecdb9c6b1f38e73fa4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga840b1c720d75ade1aa951917191ab1f8">opdis_vma_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__configuration.html#gac11d9479015d14921734cc165910e5a2">opdis_default_resolver</a> (const <a class="el" href="structopdis__insn__t.html">opdis_insn_t</a> *insn, void *arg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The built-in opdis resolver callback. This callback returns the immediate value of the taregt operand for the instruction (if set) or OPDIS_INVALID_ADDR.  <a href="#gac11d9479015d14921734cc165910e5a2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__configuration.html#ga4dd87c428ae5273ba515e23f057d7bf0">opdis_default_error_reporter</a> (enum <a class="el" href="group__disassembly.html#gae90f684a09c4afb4d2189ad97fce7095">opdis_error_t</a> error, const char *msg, void *arg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The built-in error reporter.  <a href="#ga4dd87c428ae5273ba515e23f057d7bf0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void LIBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__configuration.html#ga64f53da56263db300c5179989c725576">opdis_set_defaults</a> (<a class="el" href="structopdis__info__t.html">opdis_t</a> o)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initializes an opdis object to default, sane values.  <a href="#ga64f53da56263db300c5179989c725576"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void LIBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__configuration.html#ga257a208c2b2611f98b5c995de603680b">opdis_set_x86_syntax</a> (<a class="el" href="structopdis__info__t.html">opdis_t</a> o, enum <a class="el" href="group__configuration.html#ga3a5299b15960a05e1f75f5dfb9726b9f">opdis_x86_syntax_t</a> syntax)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Configure the disassembler to use Intel or AT&amp;T syntax.  <a href="#ga257a208c2b2611f98b5c995de603680b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void LIBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__configuration.html#ga28975603cdec9b3f23c359779360e2d6">opdis_set_arch</a> (<a class="el" href="structopdis__info__t.html">opdis_t</a> o, enum bfd_architecture arch, unsigned long mach, disassembler_ftype fn)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the architecture and disassembler routine for libopcodes.  <a href="#ga28975603cdec9b3f23c359779360e2d6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void LIBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__configuration.html#gab5a0060194eaa81f6f91d9a8dd1d632b">opdis_set_disassembler_options</a> (<a class="el" href="structopdis__info__t.html">opdis_t</a> o, const char *options)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set libopcodes disassembler options.  <a href="#gab5a0060194eaa81f6f91d9a8dd1d632b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void LIBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__configuration.html#ga147b6b4a5cdf1c7613f9c5ab4613055a">opdis_set_display</a> (<a class="el" href="structopdis__info__t.html">opdis_t</a> o, <a class="el" href="group__configuration.html#ga173e7d27078a821bd3201a01f70cfba0">OPDIS_DISPLAY</a> fn, void *arg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the callback used to display or store disassembled instructions.  <a href="#ga147b6b4a5cdf1c7613f9c5ab4613055a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void LIBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__configuration.html#ga1d33455d66bd8b6ab54e872536dbe36d">opdis_set_handler</a> (<a class="el" href="structopdis__info__t.html">opdis_t</a> o, <a class="el" href="group__configuration.html#ga37d4f948fc2b9ece769ebcf1bd49e0df">OPDIS_HANDLER</a> fn, void *arg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the callback used to determine whether to continue disassembly.  <a href="#ga1d33455d66bd8b6ab54e872536dbe36d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void LIBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__configuration.html#ga0b8981e6d86cbe9da620bd1d5c973b90">opdis_set_decoder</a> (<a class="el" href="structopdis__info__t.html">opdis_t</a> o, <a class="el" href="group__configuration.html#gaa815fec2e1e52adb3176ec4ebda45920">OPDIS_DECODER</a> fn, void *arg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the callback used to build an <a class="el" href="structopdis__insn__t.html" title="Instruction object.">opdis_insn_t</a> from libopcodes data.  <a href="#ga0b8981e6d86cbe9da620bd1d5c973b90"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void LIBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__configuration.html#ga07c4629ae65952da207df725d3b9446f">opdis_set_resolver</a> (<a class="el" href="structopdis__info__t.html">opdis_t</a> o, <a class="el" href="group__configuration.html#gab1bafa0fab6fa510abfcd8e64ca04418">OPDIS_RESOLVER</a> fn, void *arg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the callback used to obtain the buffer offset of a branch target.  <a href="#ga07c4629ae65952da207df725d3b9446f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void LIBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__configuration.html#ga78d06efa474543a0bd918f734a7f60ed">opdis_set_error_reporter</a> (<a class="el" href="structopdis__info__t.html">opdis_t</a> o, <a class="el" href="group__configuration.html#ga74777b55fa160e8eb444b7695e37818b">OPDIS_ERROR</a> fn, void *arg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the callback used to report errors.  <a href="#ga78d06efa474543a0bd918f734a7f60ed"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>API for opdis configuration. </p>
<p>The disassembly functions rely on an <a class="el" href="group__configuration.html#ga38db2ae554cc6fb7bc2f1467d4ae4c61">opdis_t</a> object to store configuration information such as <b>libopcodes</b> options and callbacks for use during disassembly. It is possible to override much of the default behavior of <b>libopdis</b> by configuring the <a class="el" href="group__configuration.html#ga38db2ae554cc6fb7bc2f1467d4ae4c61">opdis_t</a> appropriately. </p>
<p>There are two types of configuration possible: <b>disassembler configuration</b>, which determines the settings used by <b>libopcodes</b>, and <b>callback configuration</b>, which determines the behavior of <b>libopdis</b>. </p>
<p>Disassembler configuration consists of the following functions:</p>
<ul>
<li><a class="el" href="group__configuration.html#ga28975603cdec9b3f23c359779360e2d6">opdis_set_arch</a> : Set the BFD machine type and <b>print_insn</b> function used by <b>libopcodes</b>.</li>
<li><a class="el" href="group__configuration.html#gab5a0060194eaa81f6f91d9a8dd1d632b">opdis_set_disassembler_options</a> : Set architecture-specific disassembler options for <b>libopcodes</b>.</li>
<li><a class="el" href="group__configuration.html#ga257a208c2b2611f98b5c995de603680b">opdis_set_x86_syntax</a> : Set the <b>print_insn</b> function to one of the two x86 syntaxes supported by <b>libopcodes</b>. This is provided for convenience. </li>
</ul>
<p>There are five callbacks used by <b>libopdis</b> :</p>
<ul>
<li><a class="el" href="">display </a> : Invoked to display a disassembled instruction. This can be considered the instruction emitter, though the callback is expected to duplicate the instruction if it is stored as the instruction pointer passed will be overwritten when the next instruction is disassembled.</li>
<li><a class="el" href="">handler </a> : Determine whether disassembly should continue. This is used to halt disassembly if an invalid instruction is encountered or if an instruction has previously been disassembled.</li>
<li><a class="el" href="">resolver </a> : Find the VMA for the target operand of a branch instruction so that control-flow disassembly can be performed on that target. Immediate operand will have their value returned; register and address expression operands will require a VM to determine their value.</li>
<li><a class="el" href="">decoder </a> : Generate a <b>libopdis</b> instruction object from a list of strings emitted by <b>libopcodes</b>. This callback is responsible for generating all metadata for instructions.</li>
<li><a class="el" href="">error reporter </a> : Print an error message generated by <b>libopdis</b>. <dl class="note"><dt><b>Note:</b></dt><dd>The <b>opdis_t</b> is not threadsafe: it has no mutexes guarding its fields. This is especially a concern with the opdis_insn_buf_t filled by <b>libopcodes</b> as it disassembles an instruction, and is directly the result of the <b>libopcodes</b> architecture (which emits instructions to a stream). To use <b>libopdis</b> across multiple threads, a separate <a class="el" href="group__configuration.html#ga38db2ae554cc6fb7bc2f1467d4ae4c61">opdis_t</a> must be created for each thread. </dd></dl>
</li>
</ul>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="gaa815fec2e1e52adb3176ec4ebda45920"></a><!-- doxytag: member="opdis.h::OPDIS_DECODER" ref="gaa815fec2e1e52adb3176ec4ebda45920" args=")(const opdis_insn_buf_t in, opdis_insn_t *out, const opdis_byte_t *buf, opdis_off_t offset, opdis_vma_t vma, opdis_off_t length, void *arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="group__configuration.html#gaa815fec2e1e52adb3176ec4ebda45920">OPDIS_DECODER</a>)(const <a class="el" href="structopdis__insn__buffer__t.html">opdis_insn_buf_t</a>, <a class="el" href="structopdis__insn__t.html">opdis_insn_t</a> *, <a class="el" href="group__types.html#gaaf912ec32cb076f2f5b8f5d23176b386">opdis_byte_t</a> *, <a class="el" href="types_8h.html#abd14f9464752cb16147541a663f70797">opdis_off_t</a>, <a class="el" href="group__types.html#ga840b1c720d75ade1aa951917191ab1f8">opdis_vma_t</a>, <a class="el" href="types_8h.html#abd14f9464752cb16147541a663f70797">opdis_off_t</a>)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Callback used to fill an <a class="el" href="structopdis__insn__t.html" title="Instruction object.">opdis_insn_t</a> from an opdis_insn_buf_t. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>in</em>&nbsp;</td><td>The opdis_insn_buf_t containing the libopcodes output. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>out</em>&nbsp;</td><td>Pointer to the <a class="el" href="structopdis__insn__t.html" title="Instruction object.">opdis_insn_t</a> to fill. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>Buffer containing the instruction </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td>Offset of start of instruction in <em>buf</em>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vma</em>&nbsp;</td><td>Address (vma) of start of instruction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>Size of instruction in bytes. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>arg</em>&nbsp;</td><td>Optional argument to pass to callback </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on failure, nonzero on success.</dd></dl>
<p>This function is invoked after libopcodes has finished disassembling the instruction. The strings emitted from libopcodes are in the opdis_insn_buf_t; the decoder must use these to build a valid <a class="el" href="structopdis__insn__t.html" title="Instruction object.">opdis_insn_t</a>. The default decoder for unsupported architectures will only fill the ascii field of the <a class="el" href="structopdis__insn__t.html" title="Instruction object.">opdis_insn_t</a>. More sophisticated decoders, such as the decoder for the x86 platform, will fill the rest of the object. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="main.html#sec_supported_arch">Supported Architectures</a> </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The caller will only need to provide a decoder callback if they are disassembling an architecture not supported by Opdis. </dd>
<dd>
The default decoder, opdis_default_decoder, should be used by all decoder callbacks to set the basic instruction info (ascii, offset, vma, bytes, size). </dd></dl>

</div>
</div>
<a class="anchor" id="ga173e7d27078a821bd3201a01f70cfba0"></a><!-- doxytag: member="opdis.h::OPDIS_DISPLAY" ref="ga173e7d27078a821bd3201a01f70cfba0" args=")(const opdis_insn_t *i, void *arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="group__configuration.html#ga173e7d27078a821bd3201a01f70cfba0">OPDIS_DISPLAY</a>)(const <a class="el" href="structopdis__insn__t.html">opdis_insn_t</a> *i, void *arg)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Callback used to display or store a disassembled instruction. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>i</em>&nbsp;</td><td>The most recently disassembled instruction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>arg</em>&nbsp;</td><td>Argument provided when the callback is set</td></tr>
  </table>
  </dd>
</dl>
<p>This function is invoked every time an instruction is disassembled; it emits the instruction to the caller of the disassembler. The default display function writes to STDOUT. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>The caller must copy the instruction if they are going to store it; the contents of i will be overwritten when the next instruction is disassembled. </dd>
<dd>
The default display routine writes instructions to STDOUT without storing or sorting them. This will lead to unexpected behavior (i.e. out-of-order instruction listings) when using <a class="el" href="group__disassembly.html#gac25293cb2448af37755c82e192e6bb94" title="Disassemble a buffer following flow of control.">opdis_disasm_cflow()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga74777b55fa160e8eb444b7695e37818b"></a><!-- doxytag: member="opdis.h::OPDIS_ERROR" ref="ga74777b55fa160e8eb444b7695e37818b" args=")(enum opdis_error_t error, const char *msg, void *arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="group__configuration.html#ga74777b55fa160e8eb444b7695e37818b">OPDIS_ERROR</a>)(enum <a class="el" href="group__disassembly.html#gae90f684a09c4afb4d2189ad97fce7095">opdis_error_t</a> error, const char *msg, void *arg)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Callback used to handle error messages. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>Type of error. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>msg</em>&nbsp;</td><td>Detailed message describing error. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>arg</em>&nbsp;</td><td>Argument provided when the callback is set.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is invoked whenever an error is encountered by the disassembler. The default error handler writes to STDERR. </p>

</div>
</div>
<a class="anchor" id="ga37d4f948fc2b9ece769ebcf1bd49e0df"></a><!-- doxytag: member="opdis.h::OPDIS_HANDLER" ref="ga37d4f948fc2b9ece769ebcf1bd49e0df" args=")(const opdis_insn_t *i, void *arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="group__configuration.html#ga37d4f948fc2b9ece769ebcf1bd49e0df">OPDIS_HANDLER</a>)(const <a class="el" href="structopdis__insn__t.html">opdis_insn_t</a> *i, void *arg)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Callback used to determine if disassembly should continue. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>i</em>&nbsp;</td><td>The most recently disassembled instruction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>arg</em>&nbsp;</td><td>Argument provided when the callback is set </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if disassembly should halt, nonzero (1) otherwise.</dd></dl>
<p>This function is invoked after the display callback. The default behavior is to halt disassembly only if an invalid instruction is encountered. The caller can override this function in order to specify more detailed halting conditions, e.g. to halt once a sequence of instructions has been encountered. </p>

</div>
</div>
<a class="anchor" id="gab1bafa0fab6fa510abfcd8e64ca04418"></a><!-- doxytag: member="opdis.h::OPDIS_RESOLVER" ref="gab1bafa0fab6fa510abfcd8e64ca04418" args=")(const opdis_insn_t *i, void *arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga840b1c720d75ade1aa951917191ab1f8">opdis_vma_t</a>(* <a class="el" href="group__configuration.html#gab1bafa0fab6fa510abfcd8e64ca04418">OPDIS_RESOLVER</a>)(const <a class="el" href="structopdis__insn__t.html">opdis_insn_t</a> *i, void *arg)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Callback used to convert a branch target to a buffer offset. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>i</em>&nbsp;</td><td>The instruction to resolve. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>arg</em>&nbsp;</td><td>Argument provided when the callback is set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A valid offset in the buffer, or OPDIS_INVALID_ADDR.</dd></dl>
<p>This function is invoked when a branch instruction (call or jmp) is encountered; it determines the buffer offset of the branch target. This is used to convert relative addresses, virtual memory addresses, and registers into buffer offsets. If the branch target cannot be converted to a memory address (e.g. register contents are not being tracked, the load address of the buffer is not known, or the address lies outside the buffer) then this function must return OPDIS_INVALID_ADDR. The default resolver only handled relative addresses. </p>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="ga3a5299b15960a05e1f75f5dfb9726b9f"></a><!-- doxytag: member="opdis.h::opdis_x86_syntax_t" ref="ga3a5299b15960a05e1f75f5dfb9726b9f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__configuration.html#ga3a5299b15960a05e1f75f5dfb9726b9f">opdis_x86_syntax_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Syntax options for x86 disassembly. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This wraps the libopcodes syntax options, which only include Intel and AT&amp;T (i.e. no Nasm support). </dd></dl>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ga3a5299b15960a05e1f75f5dfb9726b9fa1351837bb18eb975ea5b72a01e8ca903"></a><!-- doxytag: member="opdis_x86_syntax_intel" ref="ga3a5299b15960a05e1f75f5dfb9726b9fa1351837bb18eb975ea5b72a01e8ca903" args="" -->opdis_x86_syntax_intel</em>&nbsp;</td><td>
<p>Intel syntax (dest, src) </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ga3a5299b15960a05e1f75f5dfb9726b9fa247fb272b325eb12e47a02c7f77e95d1"></a><!-- doxytag: member="opdis_x86_syntax_att" ref="ga3a5299b15960a05e1f75f5dfb9726b9fa247fb272b325eb12e47a02c7f77e95d1" args="" -->opdis_x86_syntax_att</em>&nbsp;</td><td>
<p>AT&amp;T syntax (src, dest) </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gab14a31bd82821fecdb9c6b1f38e73fa4"></a><!-- doxytag: member="opdis.c::opdis_default_decoder" ref="gab14a31bd82821fecdb9c6b1f38e73fa4" args="(const opdis_insn_buf_t in, opdis_insn_t *out, const opdis_byte_t *buf, opdis_off_t offset, opdis_vma_t vma, opdis_off_t length, void *arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int opdis_default_decoder </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structopdis__insn__buffer__t.html">opdis_insn_buf_t</a>&nbsp;</td>
          <td class="paramname"> <em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopdis__insn__t.html">opdis_insn_t</a> *&nbsp;</td>
          <td class="paramname"> <em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__types.html#gaaf912ec32cb076f2f5b8f5d23176b386">opdis_byte_t</a> *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#abd14f9464752cb16147541a663f70797">opdis_off_t</a>&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga840b1c720d75ade1aa951917191ab1f8">opdis_vma_t</a>&nbsp;</td>
          <td class="paramname"> <em>vma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#abd14f9464752cb16147541a663f70797">opdis_off_t</a>&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>arg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The built-in opdis instruction decoder This callback fills the <em>ascii</em>, <em>offset</em>, <em>vma</em>, <em>bytes</em>, and <em>size</em> fields of the output instruction object. It is recommended that all other decoders invoke this callback directly to fill these fields. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>The default decoder callback takes a NULL <em>arg</em> parameter. </dd></dl>

</div>
</div>
<a class="anchor" id="ga08732c2cdf9e14f533cbb48b6f98228f"></a><!-- doxytag: member="opdis.c::opdis_default_display" ref="ga08732c2cdf9e14f533cbb48b6f98228f" args="(const opdis_insn_t *i, void *arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opdis_default_display </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structopdis__insn__t.html">opdis_insn_t</a> *&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>arg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The built-in opdis display callback This callback writes the instruction <em>ascii</em> field to STDOUT. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>The default display callback takes a NULL <em>arg</em> parameter. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4dd87c428ae5273ba515e23f057d7bf0"></a><!-- doxytag: member="opdis.c::opdis_default_error_reporter" ref="ga4dd87c428ae5273ba515e23f057d7bf0" args="(enum opdis_error_t error, const char *msg, void *arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opdis_default_error_reporter </td>
          <td>(</td>
          <td class="paramtype">enum <a class="el" href="group__disassembly.html#gae90f684a09c4afb4d2189ad97fce7095">opdis_error_t</a>&nbsp;</td>
          <td class="paramname"> <em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>arg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The built-in error reporter. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>The default error reporter takes a NULL <em>arg</em> parameter. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3997e64314bfcffd7389ebbd0a667e4c"></a><!-- doxytag: member="opdis.c::opdis_default_handler" ref="ga3997e64314bfcffd7389ebbd0a667e4c" args="(const opdis_insn_t *insn, void *arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int opdis_default_handler </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structopdis__insn__t.html">opdis_insn_t</a> *&nbsp;</td>
          <td class="paramname"> <em>insn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>arg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The built-in opdis handler callback. The default handler returns true unless the instruction is invalid or if the address has already been visited. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>The default handler callback takes an opdis_t as the <em>arg</em> parameter. If this parameter is NULL, or if the <em>visited_addr</em> field of the opdis_t is NULL, the handler will not check check if an address has already been visited. </dd></dl>

</div>
</div>
<a class="anchor" id="gac11d9479015d14921734cc165910e5a2"></a><!-- doxytag: member="opdis.c::opdis_default_resolver" ref="gac11d9479015d14921734cc165910e5a2" args="(const opdis_insn_t *insn, void *arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga840b1c720d75ade1aa951917191ab1f8">opdis_vma_t</a> opdis_default_resolver </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structopdis__insn__t.html">opdis_insn_t</a> *&nbsp;</td>
          <td class="paramname"> <em>insn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>arg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The built-in opdis resolver callback. This callback returns the immediate value of the taregt operand for the instruction (if set) or OPDIS_INVALID_ADDR. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>The default resolver callback takes a NULL <em>arg</em> parameter. </dd></dl>

</div>
</div>
<a class="anchor" id="ga28975603cdec9b3f23c359779360e2d6"></a><!-- doxytag: member="opdis.c::opdis_set_arch" ref="ga28975603cdec9b3f23c359779360e2d6" args="(opdis_t o, enum bfd_architecture arch, unsigned long mach, disassembler_ftype fn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">opdis_set_arch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopdis__info__t.html">opdis_t</a>&nbsp;</td>
          <td class="paramname"> <em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum bfd_architecture&nbsp;</td>
          <td class="paramname"> <em>arch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>mach</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">disassembler_ftype&nbsp;</td>
          <td class="paramname"> <em>fn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the architecture and disassembler routine for libopcodes. </p>
<p>This will set architecture of the libopcodes target to a BFD architecture, and specify the libopcodes print_insn routine that will be used for disassembly. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>o</em>&nbsp;</td><td>opdis disassembler to configure. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>arch</em>&nbsp;</td><td>A valid BFD architecture from /usr/include/bfd.h. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mach</em>&nbsp;</td><td>A valid bfd_mach definition from /usr/include/bfd.h. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fn</em>&nbsp;</td><td>A valid libopcodes print_insn routine from /usr/include/dis-asm.h . </td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>If the disassembler_ftype parameter is NULL, the default disassembler for the architecture will be selected. On x86 targets, this is print_insn_i386_att. </dd>
<dd>
This sets the decoder to the appropriate built-in decoder for the architecture. To override the decoder, call opdis_set_decoder after calling this routine. </dd>
<dd>
The <em>arch</em> parameter is only used when calling <em>disassemble_init_for_target</em> to initialize the libopcodes <em>disassemble_info</em> structure. The <em>mach</em> parameter is used by the disassembler to determine how to decode the instructions. For x86 and x86-64 platforms, <em>arch</em> is always <em>bfd_arch_i386</em>, and <em>mach</em> is one of the following:<ul>
<li>bfd_mach_i386_i386</li>
<li>bfd_mach_i386_i8086</li>
<li>bfd_mach_i386_i386_intel_syntax</li>
<li>bfd_mach_x86_64</li>
<li>bfd_mach_x86_64_intel_syntax It is not necessary to specify the Intel syntax in <em>mach</em>; this can be done with <em>opdis_set_x86_syntax</em>. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga0b8981e6d86cbe9da620bd1d5c973b90"></a><!-- doxytag: member="opdis.c::opdis_set_decoder" ref="ga0b8981e6d86cbe9da620bd1d5c973b90" args="(opdis_t o, OPDIS_DECODER fn, void *arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">opdis_set_decoder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopdis__info__t.html">opdis_t</a>&nbsp;</td>
          <td class="paramname"> <em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__configuration.html#gaa815fec2e1e52adb3176ec4ebda45920">OPDIS_DECODER</a>&nbsp;</td>
          <td class="paramname"> <em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>arg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the callback used to build an <a class="el" href="structopdis__insn__t.html" title="Instruction object.">opdis_insn_t</a> from libopcodes data. </p>
<p>This sets the function used to fill an <a class="el" href="structopdis__insn__t.html" title="Instruction object.">opdis_insn_t</a> based on the array of strings (stored in an opdis_insn_buf_t) emitted by libopcodes. If the default handler does not support the ISA being disassembled (i.e. an architecture other than x86 is being used), then this must be overridden in order to get more than the ASCII version of the instruction in the <a class="el" href="structopdis__insn__t.html" title="Instruction object.">opdis_insn_t</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>o</em>&nbsp;</td><td>opdis disassembler to configure. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fn</em>&nbsp;</td><td>The callback function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>arg</em>&nbsp;</td><td>An optional argument to pass to the callback function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga64f53da56263db300c5179989c725576"></a><!-- doxytag: member="opdis.c::opdis_set_defaults" ref="ga64f53da56263db300c5179989c725576" args="(opdis_t o)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">opdis_set_defaults </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopdis__info__t.html">opdis_t</a>&nbsp;</td>
          <td class="paramname"> <em>o</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initializes an opdis object to default, sane values. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>o</em>&nbsp;</td><td>opdis disassembler to configure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__disassembly.html#ga6d51b0d9f6d24a65189c149bcfe3cfd4" title="Initialize an opdis disassembler.">opdis_init</a> <a class="el" href="group__configuration.html#ga28975603cdec9b3f23c359779360e2d6" title="Set the architecture and disassembler routine for libopcodes.">opdis_set_arch</a> <a class="el" href="group__configuration.html#ga257a208c2b2611f98b5c995de603680b" title="Configure the disassembler to use Intel or AT&amp;T syntax.">opdis_set_x86_syntax</a> opdis_set_error </dd>
<dd>
<a class="el" href="group__configuration.html#ga147b6b4a5cdf1c7613f9c5ab4613055a" title="Set the callback used to display or store disassembled instructions.">opdis_set_display</a> <a class="el" href="group__configuration.html#ga1d33455d66bd8b6ab54e872536dbe36d" title="Set the callback used to determine whether to continue disassembly.">opdis_set_handler</a> <a class="el" href="group__configuration.html#ga07c4629ae65952da207df725d3b9446f" title="Set the callback used to obtain the buffer offset of a branch target.">opdis_set_resolver</a> <a class="el" href="group__configuration.html#ga0b8981e6d86cbe9da620bd1d5c973b90" title="Set the callback used to build an opdis_insn_t from libopcodes data.">opdis_set_decoder</a> </dd>
<dd>
<a class="el" href="group__configuration.html#gab5a0060194eaa81f6f91d9a8dd1d632b" title="Set libopcodes disassembler options.">opdis_set_disassembler_options</a> </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The default architecture is i386, and the default syntax is Intel. All callbacks will be set to the default internal routines. </dd></dl>

</div>
</div>
<a class="anchor" id="gab5a0060194eaa81f6f91d9a8dd1d632b"></a><!-- doxytag: member="opdis.c::opdis_set_disassembler_options" ref="gab5a0060194eaa81f6f91d9a8dd1d632b" args="(opdis_t o, const char *options)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">opdis_set_disassembler_options </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopdis__info__t.html">opdis_t</a>&nbsp;</td>
          <td class="paramname"> <em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>options</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set libopcodes disassembler options. </p>
<p>Sets the libopcodes disassembler_options config field. Opdis passes this string blindly to libopcodes. To view the valid options for a disassembler, invoke the appropriate print_*_disassembler_options routine listed in /usr/include/dis-asm.h . </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>o</em>&nbsp;</td><td>opdis disassembler to configure. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>options</em>&nbsp;</td><td>The options string for the disassembler. </td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The libopcodes disassembler options override the settings applied by opdis_set_syntax. </dd></dl>

</div>
</div>
<a class="anchor" id="ga147b6b4a5cdf1c7613f9c5ab4613055a"></a><!-- doxytag: member="opdis.c::opdis_set_display" ref="ga147b6b4a5cdf1c7613f9c5ab4613055a" args="(opdis_t o, OPDIS_DISPLAY fn, void *arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">opdis_set_display </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopdis__info__t.html">opdis_t</a>&nbsp;</td>
          <td class="paramname"> <em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__configuration.html#ga173e7d27078a821bd3201a01f70cfba0">OPDIS_DISPLAY</a>&nbsp;</td>
          <td class="paramname"> <em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>arg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the callback used to display or store disassembled instructions. </p>
<p>This sets the function invoked to manage disassembled instructions. The callback is invoked every time an instruction is disassembled. It is expected to display or store the instruction, which will be discarded when the next address is disassembled. The default handler writes to STDOUT. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>o</em>&nbsp;</td><td>opdis disassembler to configure. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fn</em>&nbsp;</td><td>The callback function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>arg</em>&nbsp;</td><td>An optional argument to pass to the callback function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>If the callback stores the instruction, it must make a copy using <a class="el" href="group__model.html#ga6c019dce7557b07130f039ffbbdfba0f" title="Duplicate an instruction object.">opdis_insn_dupe()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga78d06efa474543a0bd918f734a7f60ed"></a><!-- doxytag: member="opdis.c::opdis_set_error_reporter" ref="ga78d06efa474543a0bd918f734a7f60ed" args="(opdis_t o, OPDIS_ERROR fn, void *arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">opdis_set_error_reporter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopdis__info__t.html">opdis_t</a>&nbsp;</td>
          <td class="paramname"> <em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__configuration.html#ga74777b55fa160e8eb444b7695e37818b">OPDIS_ERROR</a>&nbsp;</td>
          <td class="paramname"> <em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>arg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the callback used to report errors. </p>
<p>This sets the function used to report errors encountered during disassembly. The default error reporter simply writes to STDERR. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>o</em>&nbsp;</td><td>opdis disassembler to configure. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fn</em>&nbsp;</td><td>The callback function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>arg</em>&nbsp;</td><td>An optional argument to pass to the callback function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1d33455d66bd8b6ab54e872536dbe36d"></a><!-- doxytag: member="opdis.c::opdis_set_handler" ref="ga1d33455d66bd8b6ab54e872536dbe36d" args="(opdis_t o, OPDIS_HANDLER fn, void *arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">opdis_set_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopdis__info__t.html">opdis_t</a>&nbsp;</td>
          <td class="paramname"> <em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__configuration.html#ga37d4f948fc2b9ece769ebcf1bd49e0df">OPDIS_HANDLER</a>&nbsp;</td>
          <td class="paramname"> <em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>arg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the callback used to determine whether to continue disassembly. </p>
<p>This sets the function invoked to determine whether to continue linear or control-flow disassembly after each instruction has been disassembled and displayed. The default handler will halt disassembly if an invalid instruction has been encountered, or (for control-flow) if the end of a control-flow branch (i.e. a return statement) has been reached. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>o</em>&nbsp;</td><td>opdis disassembler to configure. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fn</em>&nbsp;</td><td>The callback function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>arg</em>&nbsp;</td><td>An optional argument to pass to the callback function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga07c4629ae65952da207df725d3b9446f"></a><!-- doxytag: member="opdis.c::opdis_set_resolver" ref="ga07c4629ae65952da207df725d3b9446f" args="(opdis_t o, OPDIS_RESOLVER fn, void *arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">opdis_set_resolver </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopdis__info__t.html">opdis_t</a>&nbsp;</td>
          <td class="paramname"> <em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__configuration.html#gab1bafa0fab6fa510abfcd8e64ca04418">OPDIS_RESOLVER</a>&nbsp;</td>
          <td class="paramname"> <em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>arg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the callback used to obtain the buffer offset of a branch target. </p>
<p>This sets the function used to convert the target of a branch to an offset into the buffer. The control flow disassembler will require a resolver in order to disassemble all non-relative branch targets. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>o</em>&nbsp;</td><td>opdis disassembler to configure. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fn</em>&nbsp;</td><td>The callback function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>arg</em>&nbsp;</td><td>An optional argument to pass to the callback function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The resolver receives an instruction and is expected to return a valid offset or -1 if no address can be determined. The resolver can be a subsystem that manages the stack and registers in order to provide more complete branch resolution. </dd></dl>

</div>
</div>
<a class="anchor" id="ga257a208c2b2611f98b5c995de603680b"></a><!-- doxytag: member="opdis.c::opdis_set_x86_syntax" ref="ga257a208c2b2611f98b5c995de603680b" args="(opdis_t o, enum opdis_x86_syntax_t syntax)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">opdis_set_x86_syntax </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopdis__info__t.html">opdis_t</a>&nbsp;</td>
          <td class="paramname"> <em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__configuration.html#ga3a5299b15960a05e1f75f5dfb9726b9f">opdis_x86_syntax_t</a>&nbsp;</td>
          <td class="paramname"> <em>syntax</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Configure the disassembler to use Intel or AT&amp;T syntax. </p>
<p>Sets the libopcodes print instruction to either print_insn_i386_intel or print_insn_i386_att. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>o</em>&nbsp;</td><td>opdis disassembler to configure. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>syntax</em>&nbsp;</td><td>The syntax option to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This only applies to x86 disassemblers. </dd></dl>

</div>
</div>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Tue Mar 9 18:59:32 2010 for Opdis Disassembly Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
