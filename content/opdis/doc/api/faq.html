<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Opdis Disassembly Library: FAQ</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">


<h1><a class="anchor" id="faq">FAQ </a></h1><p>General</p>
<ul>
<li><a class="el" href="faq.html#faq_general_libopcodes">Why not use libopcodes directly?</a></li>
<li><a class="el" href="faq.html#faq_general_objdump">Why use opdis instead of objdump?</a></li>
<li><a class="el" href="faq.html#faq_general_commercial">Can opdis or libopdis be used in commercial projects?</a> </li>
</ul>
<p>opdis</p>
<ul>
<li><a class="el" href="faq.html#faq_opdis_arch">What target architectures does opdis support?</a></li>
<li><a class="el" href="faq.html#faq_opdis_bfd">What are BFD targets?</a></li>
<li><a class="el" href="faq.html#faq_opdis_format">What output formats are available?</a></li>
<li><a class="el" href="faq.html#faq_opdis_fmt_str">How can the output format be customized?</a></li>
<li><a class="el" href="faq.html#faq_opdis_target">How are target IDs assigned?</a></li>
<li><a class="el" href="faq.html#faq_opdis_job">How do jobs get created?</a></li>
<li><a class="el" href="faq.html#faq_opdis_map">What are memory maps used for?</a></li>
<li><a class="el" href="faq.html#faq_opdis_map_size">Why does a memory map size not limit disassembly?</a> </li>
</ul>
<p>libopdis</p>
<ul>
<li><a class="el" href="faq.html#faq_libopdis_arch">What target architectures does libopdis support?</a></li>
<li><a class="el" href="faq.html#faq_libopdis_algo">What is the difference between linear and control flow disassembly?</a></li>
<li><a class="el" href="faq.html#faq_libopdis_vma">What is the difference between a vma and an offset?</a></li>
<li><a class="el" href="faq.html#faq_libopdis_bfd">What are the various opdis_disasm_bfd functions used for?</a></li>
<li><a class="el" href="faq.html#faq_libopdis_meta">Why is metadata not being generated for a particular architecture?</a></li>
<li><a class="el" href="faq.html#faq_libopdis_cflow_arch">Why does control flow disassembly not work for a particular architecture?</a></li>
<li><a class="el" href="faq.html#faq_libopdis_cflow_dupe">Why are duplicate instructions emitted during control flow disassembly?</a></li>
<li><a class="el" href="faq.html#faq_libopdis_decoder_when">When will additional decoders be made available?</a></li>
<li><a class="el" href="faq.html#faq_libopdis_decoder_work">How much work is it to write a decoder?</a> </li>
</ul>
<hr/>
 <h2><a class="anchor" id="faq_general">
General</a></h2>
<h3><a class="anchor" id="faq_general_objdump">
Why use opdis instead of objdump?</a></h3>
<p>The GNU <b>objdump(1)</b> utility is intended to examine the output of the <b>gcc</b> compiler and the utilities in the GNU <b>binutils</b> distribution. It cannot be used when examining file formats not supported by BFD (e.g. ROM images), and its disassembly options are limited. </p>
<p>The <b>opdis</b> utility is intended to complement <b>objdump</b> by providing a simple disassembler for object code. Features which distinguish <b>opdis</b> from <b>objdump</b> include:</p>
<ul>
<li>the ability to disassemble from an arbitrary starting point in a file</li>
<li>the ability to disassemble a string of hex bytes (e.g. shellcode)</li>
<li>a disassembly algorithm that follows control flow in the target</li>
<li>support for custom output formats via a printf-style format string </li>
</ul>
<p>The intended audience for <b>opdis</b> includes embedded system developers working with ROM images, security personnel examining shellcode strings, and software developers reverse engineering hostile or non-BFD-compliant binaries. </p>
<h3><a class="anchor" id="faq_general_libopcodes">
Why not use libopcodes directly?</a></h3>
<p>The <b>libopcodes</b> library is a very serviceable disassembler, but it has three shortcomings:</p>
<ul>
<li>it is under-documented, making it difficult for new users to understand</li>
<li>its feature set is limited to the disassembly of a single address</li>
<li>it is designed mainly to print disassembled instructions to a stream </li>
</ul>
<p>This last point in particular makes <b>libopcodes</b> unsuitable for binary analysis. </p>
<h3><a class="anchor" id="faq_general_commercial">
Can opdis or libopdis be used in commercial projects?</a></h3>
<p>Both opdis and libopdis are released under the terms of the GNU Public License (<a href="http://www.gnu.org/licenses/gpl.txt">http://www.gnu.org/licenses/gpl.txt</a>). Companies that find the terms of the GPL too restrictive can contact <a href="mailto:community@thoughtgang.org">community@thoughtgang.org</a> to discuss alternate licensing terms. </p>
<hr/>
 <h2><a class="anchor" id="faq_opdis">
opdis</a></h2>
<h3><a class="anchor" id="faq_opdis_arch">
What target architectures does opdis support?</a></h3>
<p><b>opdis</b> will support whatever architectures are supported by the locally-installed GNU <b>binutils</b>. A list of supported architectures can be displayed by using the <b>--list-architectures</b> option. </p>
<p>Note that while an architecture is supported, it may not support advanced features such as generation of metadata or control flow disassembly (which relies on metadata). A warning will be printed to STDERR if control flow disassembly is not supported on the target architecture. </p>
<h3><a class="anchor" id="faq_opdis_bfd">
What are BFD targets?</a></h3>
<p>A BFD target is a file that has been loaded using <b>libbfd</b>, part of the GNU <b>binutils</b> distribution. BFD targets have many advantages: the target architecture is automatically detected, memory maps are not required, and elements of the object file structure such as sections and symbols are available. Use of BFD targets is recommended when the target is supported by <b>libbfd</b>. </p>
<h3><a class="anchor" id="faq_opdis_format">
What output formats are available?</a></h3>
<p>The built-in output formats are:</p>
<ul>
<li>asm : raw libopcodes output</li>
<li>dump : standard disassembled listing</li>
<li>delim : pipe-delimited table of instructions</li>
<li>xml : xml representation of instructions The default output format is 'dump'. </li>
</ul>
<p>The <b>asm</b> format consists of the libopcodes strings followed by a comment containing the VMA of the instruction. </p>
<div class="fragment"><pre class="fragment">bash$ opdis -f <span class="keyword">asm</span> -E /bin/ls  |more
xor    %ebp,%ebp        # [0x4026e0]
mov    %rdx,%r9 # [0x4026e2]
pop    %rsi     # [0x4026e5]
...
callq  *%rax    # [0x40271c]
add    $0x8,%rsp        # [0x40271e]
retq    # [0x402722]
</pre></div> <p>The <b>dump</b> format consists of the instruction VMA and bytes followed by the assembly language representation of the instruction. Up to eight bytes of the instruction are printed per line. </p>
<div class="fragment"><pre class="fragment">bash$ opdis -f dump -E /bin/ls 
0x4026e0: 31 ED                      xor        %ebp, %ebp
0x4026e2: 49 89 D1                   mov        %rdx, %r9
0x4026e5: 5E                         pop        %rsi
...
0x40271c: FF D0                      callq      *%rax
0x40271e: 48 83 C4 08                add        $0x8, %rsp
0x402722: C3                         retq
</pre></div> <p>The <b>delim</b> format consists of all fields of the instruction (offset, vma, bytes, ascii, prefixes, mnemonic, isa, category, flags, and each operand) separated by pipe characters. Note that the number of operand fields will vary on each line, and there are no empty fields for operands (the maximum number of operands is not defined). The contents of each operand field are colon-delimited and consist of the fields ascii, category, flags, value, and an option (i.e. not always present) name field. The value for each operand will be a number or an object contained in curly braces; the object will be semi-colon-delimited and can be a register, absolute address, or address expression. </p>
<div class="fragment"><pre class="fragment">bash$ opdis -f delim -E /bin/ls 
offset|vma|bytes|ascii|prefixes|mnemonic|isa|category|flags|op|...
0x0|0x4026e0|31 ED|xor    %ebp,%ebp||xor|general purpose|bitwise|bitwise xor||%e
bp:<span class="keyword">register</span>:read:{ebp;6;4;general,frame ptr}:SRC|%ebp:<span class="keyword">register</span>:write:{ebp;6;4;ge
neral,frame ptr}:DEST
0x2|0x4026e2|49 89 D1|mov    %rdx,%r9||mov|general purpose|load/store|||%rdx:reg
ister:read:{rdx;3;8;general}:SRC|%r9:<span class="keyword">register</span>:write:{r9;10;8;general}:DEST
0x5|0x4026e5|5E|pop    %rsi||pop|general purpose|stack|pop||%rsi:<span class="keyword">register</span>:read:{
rsi;7;8;general}:SRC
...
0x3c|0x40271c|FF D0|callq  *%rax||callq|general purpose|control flow|call||*%rax:<span class="keyword">register</span>:read,exec:{rax;1;8;general}:TARGET
0x3e|0x40271e|48 83 C4 08|add    $0x8,%rsp||add|general purpose|arithmetic|||$0x8:immediate:read:0X8:SRC|%rsp:<span class="keyword">register</span>:write:{rsp;5;8;general,stack ptr}:DEST
0x42|0x402722|C3|retq   ||retq|general purpose|control flow|<span class="keywordflow">return</span>|
</pre></div> <p>The <b>xml</b> format produces an XML representation of each instruction along with an embedded DTD. </p>
<div class="fragment"><pre class="fragment">bash$ opdis -f xml -E /bin/ls 
&lt;?xml version=<span class="stringliteral">&quot;1.0&quot;</span>?&gt;
&lt;!DOCTYPE disassembly [
&lt;!ELEMENT disassembly (instruction*)&gt;
&lt;!ELEMENT instruction (offset,vma,bytes,ascii?,mnemonic?,prefix?,isa?,category?,
flags?,operands?,invalid?)&gt;
&lt;!ELEMENT offset (#PCDATA)&gt;
&lt;!ELEMENT vma (#PCDATA)&gt;
&lt;!ELEMENT bytes (byte+)&gt;
&lt;!ELEMENT byte (#PCDATA)&gt;
&lt;!ELEMENT ascii (#PCDATA)&gt;
&lt;!ELEMENT mnemonic (#PCDATA)&gt;
&lt;!ELEMENT prefix (#PCDATA)&gt;
&lt;!ELEMENT isa (#PCDATA)&gt;
&lt;!ELEMENT category (#PCDATA)&gt;
&lt;!ELEMENT flags (flag+)&gt;
&lt;!ELEMENT flag (#PCDATA)&gt;
&lt;!ELEMENT operands (operand*)&gt;
&lt;!ELEMENT operand (ascii,category,flags,value)&gt;
&lt;!ATTLIST operand type (target|src|dest) <span class="stringliteral">&quot;&quot;</span>&gt;
&lt;!ELEMENT value (<span class="keyword">register</span>?,immediate?,absolute?,expression?)&gt;
&lt;!ELEMENT <span class="keyword">register</span> (ascii,id,size,flags)&gt;
&lt;!ELEMENT immediate (#PCDATA)&gt;
&lt;!ELEMENT absolute (segment,immediate)&gt;
&lt;!ELEMENT segment (<span class="keyword">register</span>)&gt;
&lt;!ELEMENT expression (base?,index?,scale,shift?,displacement?)&gt;
&lt;!ELEMENT base (<span class="keyword">register</span>)&gt;
&lt;!ELEMENT index (<span class="keyword">register</span>)&gt;
&lt;!ELEMENT scale (#PCDATA)&gt;
&lt;!ELEMENT shift (#PCDATA)&gt;
&lt;!ELEMENT displacement (absolute?,immediate?)&gt;
]&gt;
&lt;disassembly&gt;
&lt;instruction&gt;
  &lt;offset&gt;0x0&lt;/offset&gt;
  &lt;vma&gt;0x4026e0&lt;/vma&gt;
  &lt;bytes&gt;
    &lt;byte&gt;31&lt;/byte&gt;
    &lt;byte&gt;ED&lt;/byte&gt;
  &lt;/bytes&gt;
  &lt;ascii&gt;xor    %ebp,%ebp&lt;/ascii&gt;
  &lt;mnemonic&gt;xor&lt;/mnemonic&gt;
  &lt;isa&gt;general purpose&lt;/isa&gt;
  &lt;category&gt;bitwise&lt;/category&gt;
  &lt;flags&gt;
    &lt;flag&gt;bitwise xor&lt;/flag&gt;
  &lt;/flags&gt;
  &lt;operands&gt;
    &lt;operand name=<span class="stringliteral">&quot;src&quot;</span>&gt;
    &lt;ascii&gt;%ebp&lt;/ascii&gt;
    &lt;category&gt;<span class="keyword">register</span>&lt;/category&gt;
    &lt;flags&gt;
      &lt;flag&gt;read&lt;/flag&gt;
    &lt;/flags&gt;
    &lt;value&gt;
      &lt;<span class="keyword">register</span>&gt;
        &lt;ascii&gt;ebp&lt;/ascii&gt;
        &lt;<span class="keywordtype">id</span>&gt;6&lt;/<span class="keywordtype">id</span>&gt;
        &lt;size&gt;4&lt;/size&gt;
        &lt;flags&gt;
          &lt;flag&gt;general&lt;/flag&gt;
          &lt;flag&gt;frame ptr&lt;/flag&gt;
        &lt;/flags&gt;
      &lt;/<span class="keyword">register</span>&gt;
    &lt;/value&gt;
    &lt;/operand&gt;
    &lt;operand name=<span class="stringliteral">&quot;dest&quot;</span>&gt;
    &lt;ascii&gt;%ebp&lt;/ascii&gt;
    &lt;category&gt;<span class="keyword">register</span>&lt;/category&gt;
    &lt;flags&gt;
      &lt;flag&gt;write&lt;/flag&gt;
    &lt;/flags&gt;
    &lt;value&gt;
      &lt;<span class="keyword">register</span>&gt;
        &lt;ascii&gt;ebp&lt;/ascii&gt;
        &lt;<span class="keywordtype">id</span>&gt;6&lt;/<span class="keywordtype">id</span>&gt;
        &lt;size&gt;4&lt;/size&gt;
        &lt;flags&gt;
          &lt;flag&gt;general&lt;/flag&gt;
          &lt;flag&gt;frame ptr&lt;/flag&gt;
        &lt;/flags&gt;
      &lt;/<span class="keyword">register</span>&gt;
    &lt;/value&gt;
    &lt;/operand&gt;
  &lt;/operands&gt;
&lt;/instruction&gt;
...
&lt;instruction&gt;
  &lt;offset&gt;0x42&lt;/offset&gt;
  &lt;vma&gt;0x402722&lt;/vma&gt;
  &lt;bytes&gt;
    &lt;byte&gt;C3&lt;/byte&gt;
  &lt;/bytes&gt;
  &lt;ascii&gt;retq   &lt;/ascii&gt;
  &lt;mnemonic&gt;retq&lt;/mnemonic&gt;
  &lt;isa&gt;general purpose&lt;/isa&gt;
  &lt;category&gt;control flow&lt;/category&gt;
  &lt;flags&gt;
    &lt;flag&gt;<span class="keywordflow">return</span>&lt;/flag&gt;
  &lt;/flags&gt;
  &lt;operands&gt;
  &lt;/operands&gt;
&lt;/instruction&gt;
&lt;/disassembly&gt;
</pre></div> <h3><a class="anchor" id="faq_opdis_fmt_str">
How can the output format be customized?</a></h3>
<p>Custom output formats can be specified using a printf- or strftime-style format string as the argument to <b>-f</b>. </p>
<p>The available format operators are:</p>
<ul>
<li><b>%i</b>[<b>ACFI</b>] : Instruction component. The component is specified using <b>A</b> (ascii, the default), <b>C</b> (category), <b>F</b> (flags), or <b>I</b> (isa).</li>
<li><b>%o</b>[<b>atds</b><em>#</em>][<b>ACF</b>] : Operand component. The operand is selected by specifying <b>a</b> (all operands, delimited by comment, the default), <b>t</b> (branch target operand), <b>d</b> (destination operand), <b>s</b> (source operand), or by specifying the operand number (0-9). The component is specified using <b>A</b> (ascii, the default), <b>C</b> (category), or <b>F</b> (flags).</li>
<li><b>%b</b>[<b>XDOC</b>] : The bytes of the instruction. The base is specified using <b>X</b> (hexadecimal), <b>D</b> (decimal), <b>O</b> (octal), or <b>C</b> (character).</li>
<li><b>%l</b> : Length of instruction in bytes</li>
<li><b>%m</b> : Instruction mnemonic</li>
<li><b>%a</b>[<b>vo</b>][<b>XDO</b>] : Instruction address. <b>v</b> or <b>o</b> selects VMA (default) or offset; the base is specified using <b>X</b> (hexadecimal), <b>D</b> (decimal), or <b>O</b> (octal).</li>
<li><b>%p</b> : Instruction prefixes</li>
<li><b>%c</b> : Instruction comment</li>
<li><b>%?</b><em>c</em> : Conditional delimiter. The delimiter (<em>c</em>) is printed only if the next <b>%</b> command (e.g. <b>%o</b>) is not empty.</li>
<li><b>%t</b> : Conditional tab delimiter</li>
<li><b>%s</b> : Conditional space delimiter</li>
<li><b>%n</b> : Conditional newline delimiter</li>
<li><b>%%</b> : Print a literal '%' </li>
</ul>
<p>Examples: </p>
<div class="fragment"><pre class="fragment">bash$ opdis -f <span class="stringliteral">&apos;%a %i\n&apos;</span> -E /bin/ls  | head -3
0x4026e0 xor    %ebp,%ebp
0x4026e2 mov    %rdx,%r9
0x4026e5 pop    %rsi
</pre></div> <div class="fragment"><pre class="fragment">bash$ opdis -f <span class="stringliteral">&apos;%ao %l [%b]\n&apos;</span> -E /bin/ls  | head -3
0x0 2 [31 ED]
0x2 3 [49 89 D1]
0x5 1 [5E]
</pre></div> <div class="fragment"><pre class="fragment">bash$ opdis -f <span class="stringliteral">&apos;[%a]%p %m\t%o\t# %b\n&apos;</span> -E /bin/ls  | head -3
[0x4026e0] xor  %ebp, %ebp      # 31 ED
[0x4026e2] mov  %rdx, %r9       # 49 89 D1
[0x4026e5] pop  %rsi    # 5E
</pre></div> <div class="fragment"><pre class="fragment">bash$ opdis -f <span class="stringliteral">&apos;%m\t%os%?,%od\n&apos;</span> -E /bin/ls  | head -3
xor     %ebp,%ebp
mov     %rdx,%r9
pop     %rsi
</pre></div> <div class="fragment"><pre class="fragment">opdis -f <span class="stringliteral">&apos;%ao: %b &quot;%bC&quot;\n&apos;</span> -E /bin/ls  | head -3
0x0: 31 ED <span class="stringliteral">&quot;1 í&quot;</span>
0x2: 49 89 D1 <span class="stringliteral">&quot;I  Ñ&quot;</span>
0x5: 5E <span class="stringliteral">&quot;^&quot;</span>
</pre></div> <div class="fragment"><pre class="fragment">bash$ opdis -f <span class="stringliteral">&apos;%a %i\t#%iC%?:%iF\n&apos;</span> -E /bin/ls  | head -3
0x4026e0 xor    %ebp,%ebp       #bitwise:bitwise xor
0x4026e2 mov    %rdx,%r9        #load/store
0x4026e5 pop    %rsi    #stack:pop
</pre></div> <h3><a class="anchor" id="faq_opdis_target">
How are target IDs assigned?</a></h3>
<p>Each target specified on the command line is assigned an ID in the order it is encountered. This means that each <b>-b</b> option is assigned an ID, followed by each file argument. </p>
<p>The command </p>
<div class="fragment"><pre class="fragment">opdis -b <span class="stringliteral">&apos;90 90 90 90&apos;</span> -b <span class="stringliteral">&apos;cc cc cc cc&apos;</span> a.out rom.bin
</pre></div><p> will assign target IDs as follows:</p>
<ol type="1">
<li>: buffer '90 90 90 90'</li>
<li>: buffer 'cc cc cc cc'</li>
<li>: file 'a.out'</li>
<li>: file 'rom.bin' Use the <b>--dry-run</b> option to preview the target list. </li>
</ol>
<h3><a class="anchor" id="faq_opdis_job">
How do jobs get created?</a></h3>
<p>Disassembly jobs are created with the <b>-l</b>, <b>-c</b>, <b>-E</b>, <b>-N</b>, and <b>-S</b> options. Jobs are scheduled in the order they are encountered. Use the <b>--dry-run</b> to preview the job list. </p>
<h3><a class="anchor" id="faq_opdis_map">
What are memory maps used for?</a></h3>
<p>Memory maps have three main uses:</p>
<ul>
<li>to change the VMA that appears in the output</li>
<li>to allow multiple files and buffers to appear contiguous in memory</li>
<li>to disassemble multiple targets This last point is worth examining in more detail. </li>
</ul>
<p>When <b>opdis</b> disassembles a target, it stores the disassembled instructions using their VMA as a primary key. The same storage is used for all targets; if an instruction is already stored for a VMA, all subsequent instructions with the same VMA will be discarded. </p>
<p>By default, the VMA for every target will be 0 (i.e., each instruction in the target will use its offset in the target as its VMA). Thus, when disassembling two targets, the instructions in the second will be discarded. Creating a memory map that places the second target after the first in memory (i.e. map it to a VMA equal to the first target's size) fixes this issue. </p>
<p>Note that BFD targets do not require memory maps, as the BFD structure contains sections that provide their own mapping. Also, all <b>-b</b> options are mapped sequentially in memory, so that they appear to be part of the same contiguous memory region. </p>
<h3><a class="anchor" id="faq_opdis_map_size">
Why does a memory map size not limit disassembly?</a></h3>
<p>The memory maps are only used when scheduling jobs. Once disassembly starts, libopcodes is invoked in a loop using the <b>disassemble_info</b> structure contained in the opdis_. This structure uses the target buffer to determine the bounds of disassembly. </p>
<hr/>
 <h2><a class="anchor" id="faq_libopdis">
libopdis</a></h2>
<h3><a class="anchor" id="faq_libopdis_arch">
What target architectures does libopdis support?</a></h3>
<p><b>libopdis</b> will support whatever architectures are supported by the locally-installed GNU <b>binutils</b>. The list of architectures and file formats that <b>binutils</b> supports can be displayed by running <em>objdump -i</em>. </p>
<p>Note that basic support for an architecture only means that the <em>ascii</em>, <em>offset</em>, <em>vma</em>, <em>size</em>, and <em>bytes</em> fields of the <a class="el" href="structopdis__insn__t.html">opdis_insn_t</a> are guaranteed to be filled. All other fields, including the operand list, require that an architecture-specific decoder function be invoked by <b>libopdis</b>. Use the <em>status</em> field to determine if any of these additional fields have been filled. </p>
<p>Currently, <b>libopdis</b> ships only with an i386 (x86, x86-64) decoder. </p>
<h3><a class="anchor" id="faq_libopdis_algo">
What is the difference between linear and control flow disassembly?</a></h3>
<p>Most disassemblers, including <b>objdump(1)</b>, implement what is known as <em>linear</em> or <em>linear sweep</em> disassembly: the algorithm starts disassembly at a given entry point, using the byte after a disassembled instruction as the start of the next instruction. This type of disassembly is fast and easy to implement, as there is no analysis of the instruction needed, and no danger of getting caught in an endless loop. </p>
<p><em>Control-flow</em> disassembly attempts to follow the flow of control in a program as it disassembles instructions. The algorithm starts disassembly at an entry point, then examines the instruction to see if it is a branch (call or conditional jump), a jump, or a return. Branch instructions and jump instructions examine the target operand and begin disassembly at that location. Once the disassembly of the target operand is complete, branch instructions will continue disassembly at the byte after the current instruction, while jump instructions will stop disassemby. Return instructions always halt disassembly. </p>
<p>The implementation of control-flow disassembly is much more tricky than linear disassembly. A list of disassembled addresses must be maintained to avoid getting trapped in an endless loop (this may be reduced to a list of branch targets that have been visited, at the price of redundant disassembly). Each instruction must be analyzed to determine if it is a branch, jump, or return; in addition, the operand of these instructions must be analyzed and resolved to a vma if it is a register or reference. </p>
<p>While control-flow disassembly is more accurate than linear disassembly, it is still not perfect: instructions found by a linear disassembler might only be reachable by jumping to the contents of a register. It is recommended that control flow disassembly of the symbols and entry point in a program be supplemented by the linear disassembly of all executable and loadable sections in the program: instructions which are duplicates or which begin inside of existing instructions should be discarded. </p>
<h3><a class="anchor" id="faq_libopdis_vma">
What is the difference between a vma and an offset?</a></h3>
<p>An offset is an index into a buffer of bytes, with offset 0 being the first item of the buffer and offset (buffer.size - 1) being the offset of the last item in the buffer. </p>
<p>A <em>vma</em> or <em>virtual memory address</em> is the load address of an offset. Some buffer contents (e.g. an executable code segment in a binary file) assume they have been loaded to a specific virtual address; this virtual address is used as the vma for the buffer. This vma is added to an offset into the buffer in order to determine the vma for an instruction. </p>
<p>A buffer can always have a load address of 0, meaning that the vma and the offset will be identical for its contents. </p>
<h3><a class="anchor" id="faq_libopdis_bfd">
What are the various opdis_disasm_bfd functions used for?</a></h3>
<p>The BFD support provided by <b>libopdis</b> consists of a configuration function and five disassembly functions:</p>
<ul>
<li><a class="el" href="group__bfd.html#gae374625fb321f79356f99ca3d37d928b">opdis_init_from_bfd</a> : create an <a class="el" href="group__configuration.html#ga38db2ae554cc6fb7bc2f1467d4ae4c61">opdis_t</a> from a <b>bfd</b> object</li>
<li><a class="el" href="group__bfd.html#ga866a5c9228044a433239c46ad130a38c">opdis_disasm_bfd_linear</a> : linear disassembly on a vma in a <b>bfd</b> object</li>
<li><a class="el" href="group__bfd.html#ga0c5021e97119dd49cabef83edfd42858">opdis_disasm_bfd_cflow</a> : control-flow disassembly on a vma in a <b>bfd</b> object</li>
<li><a class="el" href="group__bfd.html#ga7e41726af2386e31480f9ddd9a9a0951">opdis_disasm_bfd_section</a> : linear disassembly on a <b>bfd</b> section</li>
<li><a class="el" href="group__bfd.html#gac9b2f1ca6de3df7dcdd213b3c6823dd2">opdis_disasm_bfd_symbol</a> : control-flow disassembly on a <b>bfd</b> symbol</li>
<li><a class="el" href="group__bfd.html#ga81464351aa77cd893bc6c22babb08083">opdis_disasm_bfd_entry</a> : control-flow disassembly on the entry point of a <b>bfd</b> object Using <b>libbfd</b> to manage <b>libopdis</b> targets has some advantages and disadvantages. On the positive side, it simplifies the loading of the target by detecting the architecture, and provides access to symbolic information such as program sections and symbol tables. On the negative side, <b>libbfd</b> will fail to load a file which has malformed or missing headers, or which is not in a recognized file format. </li>
</ul>
<p>It is recommended that users employ the BFD API where suitable, while keeping the standard API in reserve to handle files that BFD fails to load. </p>
<h3><a class="anchor" id="faq_libopdis_meta">
Why is metadata not being generated for a particular architecture?</a></h3>
<p>The disassembly generated by <b>libopcodes</b> is a sequence of strings intended for writing to a stream. There is no metadata, so the strings must be examined to determine which are mnemonics and which are operands, and which of these are branch/jump/return instructions and what their targets are. </p>
<p>This means that the logic which generates an <a class="el" href="structopdis__insn__t.html">opdis_insn_t</a> from <b>libopcodes</b> output must be able to parse every assembly language that is supported by GNU <b>binutils</b>. Doing do would, it goes without saying, be a long and time-consuming endeavor that only delay the release of <b>libopdis</b>. Instead, metadata support for the x86 architecture has been provided, and support for additional architectures will be add as time and merit warrant. </p>
<h3><a class="anchor" id="faq_libopdis_cflow_arch">
Why does control flow disassembly not work for a particular architecture?</a></h3>
<p>The control-flow algorithm requires that metadata be generated for every instruction disassembled by <b>libopcodes</b>. As discussed in <a class="el" href="faq.html#faq_libopdis_meta">Why is metadata not being generated for a particular architecture?</a>, this is infeasible, so most architectures supported by <b>libopcodes</b> will have no metadata generated by <b>libopdis</b>. </p>
<p>Those in need of control-flow disassembly on an architecture for which metadata support is missing may want to write their own decoder callback (see <a class="el" href="faq.html#faq_libopdis_decoder_work">How much work is it to write a decoder?</a>) to provide the metadata to <b>libopdis</b>. </p>
<h3><a class="anchor" id="faq_libopdis_cflow_dupe">
Why are duplicate instructions emitted during control flow disassembly?</a></h3>
<p>When using the default display callback, or any display callback that does not perform its own instruction management, the same instruction may be disassembled multiple times. </p>
<p>The reason for this behavior is briefly mentioned in libopdis_algo: the control-flow algorithm has a choice of storing every address it disassembles, or only branch targets. In the interest of efficiency, the latter approach is taken by default: an <a class="el" href="group__tree.html#ga25fa98bbacc954bc88721a8181140274">opdis_vma_tree_t</a> is allocated by the control-flow function and used to track visited branch targets until disassembly is complete. This has some unfortunate consequences:</p>
<ul>
<li>If an address has already been disassembled (e.g. via a conditional jump), and the disassembler encounters it as a subsequent instruction instead of a branch target, it will be disassembled and displayed again, along with all subsequent instructions.</li>
<li>Addresses visited as branch targets in one invocation of a control-flow function (such as <a class="el" href="group__disassembly.html#gac25293cb2448af37755c82e192e6bb94">opdis_disasm_cflow</a>) will not be known to subsequent invocations of control-flow functions, and will be disassembled and displayed again. </li>
</ul>
<p>There are two solutions to this problem. The first is to write a display callback which adds instructions to an <a class="el" href="group__tree.html#gaa9a9d27400c3b328fc91e68f513dcfa7">opdis_insn_tree_t</a> during disassembly, then print that tree when disassembly is complete. The second is to enable visited-address checking in the default handler by allocating the <b>visited_addr</b> field of the <a class="el" href="group__configuration.html#ga38db2ae554cc6fb7bc2f1467d4ae4c61">opdis_t</a> as shown: </p>
<div class="fragment"><pre class="fragment">opdis-&gt;visited_addr = <a class="code" href="group__tree.html#gacf3ae7b1e576bc22fe5d0500b6255103" title="Allocate an Address Tree.">opdis_vma_tree_init</a>();
</pre></div><p> Note: This will slow down disassembly considerably. </p>
<h3><a class="anchor" id="faq_libopdis_decoder_when">
When will additional decoders be made available?</a></h3>
<p>There are currently no plans to develop additional decoders for <b>libopdis</b>; the x86 decoder currently meets the needs of the <b>libopdis</b> developers. If there is sufficient demand, work might begin on ARM, SPARK, or IA-64 decoders. Submissions of decoder implementations for any architecture are of course welcome. </p>
<h3><a class="anchor" id="faq_libopdis_decoder_work">
How much work is it to write a decoder?</a></h3>
<p>As discussed in <a class="el" href="faq.html#faq_libopdis_meta">Why is metadata not being generated for a particular architecture?</a>, <b>libopcodes</b> generates a sequence of strings for each instruction; <b>libopdis</b> stores these in an opdis_insn_buf_t. This means that a decoder must scan through a list of strings in order to detect instruction mnemonics and operands. </p>
<p>For the simple case of supporting control-flow disassembly, this is not too much work. The decoder can scan for the handful of relevant instructions, then generate an operand for the branch target and set all relevant metadata (instruction category, instruction flags, operand category, operand flags, instruction target operand pointer). </p>
<p>More complete support of an architecture, such as detection of register flags or stack trap instruction types, is a great deal of work, and should ideally be automated. </p>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Tue Mar 9 05:18:27 2010 for Opdis Disassembly Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
