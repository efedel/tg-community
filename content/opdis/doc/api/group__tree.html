<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Opdis Disassembly Library: Tree</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Tree</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopdis__tree__node__t.html">opdis_tree_node_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A node in an AVL tree.  <a href="structopdis__tree__node__t.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopdis__tree__base__t.html">opdis_tree_base_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The base of the tree.  <a href="structopdis__tree__base__t.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void *(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tree.html#ga9180b9d87d36983f5b90a30602be3f5c">OPDIS_TREE_KEY_FN</a> )(void *item)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Callback to get the key for an item stored in a tree.  <a href="#ga9180b9d87d36983f5b90a30602be3f5c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tree.html#gafc668ddef58f0c8b61e1ae4936c5f2b1">OPDIS_TREE_CMP_FN</a> )(void *a, void *b)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Callback to compare two keys.  <a href="#gafc668ddef58f0c8b61e1ae4936c5f2b1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tree.html#ga79013cbca91b34050f9955b8c0314c37">OPDIS_TREE_FREE_FN</a> )(void *item)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Callback to free items stored in the tree.  <a href="#ga79013cbca91b34050f9955b8c0314c37"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga013ea7dc0b686af81ac53642a8bd18f9"></a><!-- doxytag: member="tree::opdis_tree_t" ref="ga013ea7dc0b686af81ac53642a8bd18f9" args="" -->
typedef <a class="el" href="structopdis__tree__base__t.html">opdis_tree_base_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tree.html#ga013ea7dc0b686af81ac53642a8bd18f9">opdis_tree_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A generic AVL tree. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga25fa98bbacc954bc88721a8181140274"></a><!-- doxytag: member="tree::opdis_vma_tree_t" ref="ga25fa98bbacc954bc88721a8181140274" args="" -->
typedef <a class="el" href="structopdis__tree__base__t.html">opdis_tree_base_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tree.html#ga25fa98bbacc954bc88721a8181140274">opdis_vma_tree_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An AVL tree for storing opdis addresses. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa9a9d27400c3b328fc91e68f513dcfa7"></a><!-- doxytag: member="tree::opdis_insn_tree_t" ref="gaa9a9d27400c3b328fc91e68f513dcfa7" args="" -->
typedef <a class="el" href="structopdis__tree__base__t.html">opdis_tree_base_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tree.html#gaa9a9d27400c3b328fc91e68f513dcfa7">opdis_insn_tree_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An AVL tree for storing opdis instructions. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tree.html#ga88ee674c3febf1db56ad04a56e54354f">OPDIS_TREE_FOREACH_FN</a> )(void *item, void *arg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Callback invoked by opdis_tree_foreach.  <a href="#ga88ee674c3febf1db56ad04a56e54354f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tree.html#ga3527a2610bb81bb8ce808ce8d3504024">OPDIS_ADDR_TREE_FOREACH_FN</a> )(<a class="el" href="group__types.html#ga840b1c720d75ade1aa951917191ab1f8">opdis_vma_t</a> addr, void *arg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Callback invoked for every address emitted by opdis_vma_tree_foreach.  <a href="#ga3527a2610bb81bb8ce808ce8d3504024"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tree.html#ga46cfcea09c56d8e5f7521847d3c31336">OPDIS_INSN_TREE_FOREACH_FN</a> )(<a class="el" href="structopdis__insn__t.html">opdis_insn_t</a> *insn, void *arg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Callback invoked for each insn emitted by opdis_insn_tree_foreach.  <a href="#ga46cfcea09c56d8e5f7521847d3c31336"></a><br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structopdis__tree__base__t.html">opdis_tree_t</a> LIBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tree.html#ga22b76ad142396b401e22715d4587f95a">opdis_tree_init</a> (<a class="el" href="group__tree.html#ga9180b9d87d36983f5b90a30602be3f5c">OPDIS_TREE_KEY_FN</a> key_fn, <a class="el" href="group__tree.html#gafc668ddef58f0c8b61e1ae4936c5f2b1">OPDIS_TREE_CMP_FN</a> cmp_fn, <a class="el" href="group__tree.html#ga79013cbca91b34050f9955b8c0314c37">OPDIS_TREE_FREE_FN</a> free_fn)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate and initialize for an AVL tree.  <a href="#ga22b76ad142396b401e22715d4587f95a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int LIBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tree.html#ga8a76f83b3101f328cf13fab8cc52ee99">opdis_tree_add</a> (<a class="el" href="structopdis__tree__base__t.html">opdis_tree_t</a> tree, void *data)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert a node into the tree.  <a href="#ga8a76f83b3101f328cf13fab8cc52ee99"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int LIBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tree.html#ga12e57c33362503697d48546b9cb34fee">opdis_tree_update</a> (<a class="el" href="structopdis__tree__base__t.html">opdis_tree_t</a> tree, void *data)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert or overwrite a node in the tree.  <a href="#ga12e57c33362503697d48546b9cb34fee"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int LIBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tree.html#ga5031ec643ffc62cf06740acac9a30d9c">opdis_tree_delete</a> (<a class="el" href="structopdis__tree__base__t.html">opdis_tree_t</a> tree, void *key)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove an item from the tree.  <a href="#ga5031ec643ffc62cf06740acac9a30d9c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int LIBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tree.html#ga9316ed0eee330a79551d029b40fd1072">opdis_tree_contains</a> (<a class="el" href="structopdis__tree__base__t.html">opdis_tree_t</a> tree, void *key)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine if tree contains data.  <a href="#ga9316ed0eee330a79551d029b40fd1072"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *LIBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tree.html#ga2281a61dffaabd508597bfdf2284d2c1">opdis_tree_find</a> (<a class="el" href="structopdis__tree__base__t.html">opdis_tree_t</a> tree, void *key)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find data in a tree.  <a href="#ga2281a61dffaabd508597bfdf2284d2c1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tree.html#ga3083058128d342b87489c70d1592eb3e">opdis_tree_closest</a> (<a class="el" href="structopdis__tree__base__t.html">opdis_tree_t</a> tree, void *key)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find closest match to data in a tree. This returns the item that matches the key, or the item that is closest to (but less than) the key, or NULL if there is no item less than or equal to the key.  <a href="#ga3083058128d342b87489c70d1592eb3e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tree.html#gae73b720c82a6238b630a4b2e822fbcd6">opdis_tree_next</a> (<a class="el" href="structopdis__tree__base__t.html">opdis_tree_t</a> tree, void *key)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the data succeeding the key in a tree. This returns the item that occurs immediately after <em>key</em> in the tree, or immediately after where <em>key</em> would be if it were in the tree. If there are no items greater than <em>key</em> in the tree, this returns NULL.  <a href="#gae73b720c82a6238b630a4b2e822fbcd6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void LIBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tree.html#gac6c7ca14f83de83a2b92b709264632d3">opdis_tree_foreach</a> (<a class="el" href="structopdis__tree__base__t.html">opdis_tree_t</a> tree, <a class="el" href="group__tree.html#ga88ee674c3febf1db56ad04a56e54354f">OPDIS_TREE_FOREACH_FN</a> fn, void *arg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterate over the tree, invoking a callback for each item.  <a href="#gac6c7ca14f83de83a2b92b709264632d3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t LIBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tree.html#ga2de4dfdef1fd7612a013552bbb482db6">opdis_tree_count</a> (<a class="el" href="structopdis__tree__base__t.html">opdis_tree_t</a> tree)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the number of items in the tree.  <a href="#ga2de4dfdef1fd7612a013552bbb482db6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void LIBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tree.html#ga1366172141006ea2f7059d42a0261350">opdis_tree_free</a> (<a class="el" href="structopdis__tree__base__t.html">opdis_tree_t</a> tree)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free an AVL tree.  <a href="#ga1366172141006ea2f7059d42a0261350"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structopdis__tree__base__t.html">opdis_vma_tree_t</a> LIBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tree.html#gacf3ae7b1e576bc22fe5d0500b6255103">opdis_vma_tree_init</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate an Address Tree.  <a href="#gacf3ae7b1e576bc22fe5d0500b6255103"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int LIBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tree.html#ga608fad768551cdc684bc101898236b5d">opdis_vma_tree_add</a> (<a class="el" href="structopdis__tree__base__t.html">opdis_vma_tree_t</a> tree, <a class="el" href="group__types.html#ga840b1c720d75ade1aa951917191ab1f8">opdis_vma_t</a> addr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert an address into the tree.  <a href="#ga608fad768551cdc684bc101898236b5d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int LIBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tree.html#gaf49febac0551efc64e598a22550a27b7">opdis_vma_tree_delete</a> (<a class="el" href="structopdis__tree__base__t.html">opdis_vma_tree_t</a> tree, <a class="el" href="group__types.html#ga840b1c720d75ade1aa951917191ab1f8">opdis_vma_t</a> addr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete an address from the tree.  <a href="#gaf49febac0551efc64e598a22550a27b7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int LIBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tree.html#ga26e6b33a60e66aa0be5bd4c8c721ab7b">opdis_vma_tree_contains</a> (<a class="el" href="structopdis__tree__base__t.html">opdis_vma_tree_t</a> tree, <a class="el" href="group__types.html#ga840b1c720d75ade1aa951917191ab1f8">opdis_vma_t</a> addr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine if an address is in the tree.  <a href="#ga26e6b33a60e66aa0be5bd4c8c721ab7b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga840b1c720d75ade1aa951917191ab1f8">opdis_vma_t</a> LIBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tree.html#ga47bf5f8ecf7e79bf90537c801ab7f9a8">opdis_vma_tree_find</a> (<a class="el" href="structopdis__tree__base__t.html">opdis_vma_tree_t</a> tree, <a class="el" href="group__types.html#ga840b1c720d75ade1aa951917191ab1f8">opdis_vma_t</a> addr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find an address in the tree.  <a href="#ga47bf5f8ecf7e79bf90537c801ab7f9a8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void LIBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tree.html#gae69a7b66b8f3ff62c201c09e325c23aa">opdis_vma_tree_foreach</a> (<a class="el" href="structopdis__tree__base__t.html">opdis_vma_tree_t</a> tree, <a class="el" href="group__tree.html#ga3527a2610bb81bb8ce808ce8d3504024">OPDIS_ADDR_TREE_FOREACH_FN</a> fn, void *arg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Invoke a callback for every item in the tree.  <a href="#gae69a7b66b8f3ff62c201c09e325c23aa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void LIBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tree.html#ga794c82fb6567c84f30b99014f8934013">opdis_vma_tree_free</a> (<a class="el" href="structopdis__tree__base__t.html">opdis_vma_tree_t</a> tree)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free the address tree.  <a href="#ga794c82fb6567c84f30b99014f8934013"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structopdis__tree__base__t.html">opdis_insn_tree_t</a> LIBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tree.html#gaf9663d376c0bba8f90ee0602d2733f27">opdis_insn_tree_init</a> (int manage)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate an Instruction Tree.  <a href="#gaf9663d376c0bba8f90ee0602d2733f27"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int LIBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tree.html#gaba70d76551d478f6ee815555f8e7d814">opdis_insn_tree_add</a> (<a class="el" href="structopdis__tree__base__t.html">opdis_insn_tree_t</a> tree, <a class="el" href="structopdis__insn__t.html">opdis_insn_t</a> *insn)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert an instruction into the tree.  <a href="#gaba70d76551d478f6ee815555f8e7d814"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int LIBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tree.html#gada866fbac43b77800d7292c6bd0cb7c7">opdis_insn_tree_delete</a> (<a class="el" href="structopdis__tree__base__t.html">opdis_insn_tree_t</a> tree, <a class="el" href="group__types.html#ga840b1c720d75ade1aa951917191ab1f8">opdis_vma_t</a> addr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete an instruction from the tree.  <a href="#gada866fbac43b77800d7292c6bd0cb7c7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int LIBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tree.html#gaaa9d7386ecb10dda43e487fb38a0e331">opdis_insn_tree_contains</a> (<a class="el" href="structopdis__tree__base__t.html">opdis_insn_tree_t</a> tree, <a class="el" href="group__types.html#ga840b1c720d75ade1aa951917191ab1f8">opdis_vma_t</a> addr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine if an instruction is in the tree.  <a href="#gaaa9d7386ecb10dda43e487fb38a0e331"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structopdis__insn__t.html">opdis_insn_t</a> *LIBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tree.html#gac711ca718d8cbd313bf0d5f075e8bbff">opdis_insn_tree_find</a> (<a class="el" href="structopdis__tree__base__t.html">opdis_insn_tree_t</a> tree, <a class="el" href="group__types.html#ga840b1c720d75ade1aa951917191ab1f8">opdis_vma_t</a> addr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find an instruction in the tree.  <a href="#gac711ca718d8cbd313bf0d5f075e8bbff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void LIBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tree.html#gaba90a447a4ec0a905b8f52605e29c42d">opdis_insn_tree_foreach</a> (<a class="el" href="structopdis__tree__base__t.html">opdis_insn_tree_t</a> tree, <a class="el" href="group__tree.html#ga46cfcea09c56d8e5f7521847d3c31336">OPDIS_INSN_TREE_FOREACH_FN</a> fn, void *arg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Invoke a callback for every item in the tree.  <a href="#gaba90a447a4ec0a905b8f52605e29c42d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void LIBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tree.html#ga3871dfb18bb29c2bdf4d80456fc74a15">opdis_insn_tree_free</a> (<a class="el" href="structopdis__tree__base__t.html">opdis_insn_tree_t</a> tree)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free the instruction tree.  <a href="#ga3871dfb18bb29c2bdf4d80456fc74a15"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>AVL trees for opdis addresses and instructions. </p>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="ga3527a2610bb81bb8ce808ce8d3504024"></a><!-- doxytag: member="tree.h::OPDIS_ADDR_TREE_FOREACH_FN" ref="ga3527a2610bb81bb8ce808ce8d3504024" args=")(opdis_vma_t addr, void *arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="group__tree.html#ga3527a2610bb81bb8ce808ce8d3504024">OPDIS_ADDR_TREE_FOREACH_FN</a>)(<a class="el" href="group__types.html#ga840b1c720d75ade1aa951917191ab1f8">opdis_vma_t</a>, void *)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>addr</em>&nbsp;</td><td>The address. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>arg</em>&nbsp;</td><td>Argument provided to opdis_vma_tree_foreach </td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>A zero return value will break out of the foreach. </dd></dl>

</div>
</div>
<a class="anchor" id="ga46cfcea09c56d8e5f7521847d3c31336"></a><!-- doxytag: member="tree.h::OPDIS_INSN_TREE_FOREACH_FN" ref="ga46cfcea09c56d8e5f7521847d3c31336" args=")(opdis_insn_t *insn, void *arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="group__tree.html#ga46cfcea09c56d8e5f7521847d3c31336">OPDIS_INSN_TREE_FOREACH_FN</a>)(<a class="el" href="structopdis__insn__t.html">opdis_insn_t</a> *, void *)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>addr</em>&nbsp;</td><td>The instruction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>arg</em>&nbsp;</td><td>Argument provided to opdis_insn_tree_foreach </td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>A zero return value will break out of the foreach. </dd></dl>

</div>
</div>
<a class="anchor" id="gafc668ddef58f0c8b61e1ae4936c5f2b1"></a><!-- doxytag: member="tree.h::OPDIS_TREE_CMP_FN" ref="gafc668ddef58f0c8b61e1ae4936c5f2b1" args=")(void *a, void *b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="group__tree.html#gafc668ddef58f0c8b61e1ae4936c5f2b1">OPDIS_TREE_CMP_FN</a>)(void *, void *)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a</em>&nbsp;</td><td>The first key. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>The second key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>-1, 0, 1 if a is &lt;, ==, or &gt; b</dd></dl>
<p>This function is called to determine if the first item is before, after, or equal in order to the second item. </p>

</div>
</div>
<a class="anchor" id="ga88ee674c3febf1db56ad04a56e54354f"></a><!-- doxytag: member="tree.h::OPDIS_TREE_FOREACH_FN" ref="ga88ee674c3febf1db56ad04a56e54354f" args=")(void *item, void *arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="group__tree.html#ga88ee674c3febf1db56ad04a56e54354f">OPDIS_TREE_FOREACH_FN</a>)(void *, void *)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>item</em>&nbsp;</td><td>The current item. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>arg</em>&nbsp;</td><td>The argument provided to opdis_tree_foreach. </td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>A zero return value will break out of the foreach. </dd></dl>

</div>
</div>
<a class="anchor" id="ga79013cbca91b34050f9955b8c0314c37"></a><!-- doxytag: member="tree.h::OPDIS_TREE_FREE_FN" ref="ga79013cbca91b34050f9955b8c0314c37" args=")(void *item)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="group__tree.html#ga79013cbca91b34050f9955b8c0314c37">OPDIS_TREE_FREE_FN</a>)(void *)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>item</em>&nbsp;</td><td>The item to free. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9180b9d87d36983f5b90a30602be3f5c"></a><!-- doxytag: member="tree.h::OPDIS_TREE_KEY_FN" ref="ga9180b9d87d36983f5b90a30602be3f5c" args=")(void *item)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void *(* <a class="el" href="group__tree.html#ga9180b9d87d36983f5b90a30602be3f5c">OPDIS_TREE_KEY_FN</a>)(void *)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>item</em>&nbsp;</td><td>The item in the tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Key for item</dd></dl>
<p>This function is invoked in order to retrieve the key for an item stored in the tree. </p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gaba70d76551d478f6ee815555f8e7d814"></a><!-- doxytag: member="tree.c::opdis_insn_tree_add" ref="gaba70d76551d478f6ee815555f8e7d814" args="(opdis_insn_tree_t tree, opdis_insn_t *insn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int opdis_insn_tree_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopdis__tree__base__t.html">opdis_insn_tree_t</a>&nbsp;</td>
          <td class="paramname"> <em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopdis__insn__t.html">opdis_insn_t</a> *&nbsp;</td>
          <td class="paramname"> <em>insn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tree</em>&nbsp;</td><td>The Instruction Tree. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>insn</em>&nbsp;</td><td>The instruction to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if instruction was added, 0 if instruction exists. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__tree.html#gada866fbac43b77800d7292c6bd0cb7c7" title="Delete an instruction from the tree.">opdis_insn_tree_delete</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaaa9d7386ecb10dda43e487fb38a0e331"></a><!-- doxytag: member="tree.c::opdis_insn_tree_contains" ref="gaaa9d7386ecb10dda43e487fb38a0e331" args="(opdis_insn_tree_t tree, opdis_vma_t addr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int opdis_insn_tree_contains </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopdis__tree__base__t.html">opdis_insn_tree_t</a>&nbsp;</td>
          <td class="paramname"> <em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga840b1c720d75ade1aa951917191ab1f8">opdis_vma_t</a>&nbsp;</td>
          <td class="paramname"> <em>addr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tree</em>&nbsp;</td><td>The Instruction Tree. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>addr</em>&nbsp;</td><td>The address to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if the address is in the tree, 0 otherwise. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__tree.html#ga9316ed0eee330a79551d029b40fd1072" title="Determine if tree contains data.">opdis_tree_contains</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gada866fbac43b77800d7292c6bd0cb7c7"></a><!-- doxytag: member="tree.c::opdis_insn_tree_delete" ref="gada866fbac43b77800d7292c6bd0cb7c7" args="(opdis_insn_tree_t tree, opdis_vma_t addr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int opdis_insn_tree_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopdis__tree__base__t.html">opdis_insn_tree_t</a>&nbsp;</td>
          <td class="paramname"> <em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga840b1c720d75ade1aa951917191ab1f8">opdis_vma_t</a>&nbsp;</td>
          <td class="paramname"> <em>addr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tree</em>&nbsp;</td><td>The Instruction Tree. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>insn</em>&nbsp;</td><td>The instruction to delete. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 on success, 0 on failure. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__tree.html#gaba70d76551d478f6ee815555f8e7d814" title="Insert an instruction into the tree.">opdis_insn_tree_add</a> </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The instruction is freed if the Instruction Tree was created with <em>manage</em> set to 1. </dd></dl>

</div>
</div>
<a class="anchor" id="gac711ca718d8cbd313bf0d5f075e8bbff"></a><!-- doxytag: member="tree.c::opdis_insn_tree_find" ref="gac711ca718d8cbd313bf0d5f075e8bbff" args="(opdis_insn_tree_t tree, opdis_vma_t addr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopdis__insn__t.html">opdis_insn_t</a> * opdis_insn_tree_find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopdis__tree__base__t.html">opdis_insn_tree_t</a>&nbsp;</td>
          <td class="paramname"> <em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga840b1c720d75ade1aa951917191ab1f8">opdis_vma_t</a>&nbsp;</td>
          <td class="paramname"> <em>addr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tree</em>&nbsp;</td><td>The Instruction Tree. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>addr</em>&nbsp;</td><td>The address of the instruction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The instruction or NULL. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__tree.html#ga2281a61dffaabd508597bfdf2284d2c1" title="Find data in a tree.">opdis_tree_find</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaba90a447a4ec0a905b8f52605e29c42d"></a><!-- doxytag: member="tree.c::opdis_insn_tree_foreach" ref="gaba90a447a4ec0a905b8f52605e29c42d" args="(opdis_insn_tree_t tree, OPDIS_INSN_TREE_FOREACH_FN fn, void *arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opdis_insn_tree_foreach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopdis__tree__base__t.html">opdis_insn_tree_t</a>&nbsp;</td>
          <td class="paramname"> <em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__tree.html#ga46cfcea09c56d8e5f7521847d3c31336">OPDIS_INSN_TREE_FOREACH_FN</a>&nbsp;</td>
          <td class="paramname"> <em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>arg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tree</em>&nbsp;</td><td>The Instruction Tree. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fn</em>&nbsp;</td><td>The callback to invoke for each instruction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>arg</em>&nbsp;</td><td>An optional argument to pass to the callback function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3871dfb18bb29c2bdf4d80456fc74a15"></a><!-- doxytag: member="tree.c::opdis_insn_tree_free" ref="ga3871dfb18bb29c2bdf4d80456fc74a15" args="(opdis_insn_tree_t tree)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opdis_insn_tree_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopdis__tree__base__t.html">opdis_insn_tree_t</a>&nbsp;</td>
          <td class="paramname"> <em>tree</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tree</em>&nbsp;</td><td>The instruction Tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__tree.html#gaf9663d376c0bba8f90ee0602d2733f27" title="Allocate an Instruction Tree.">opdis_insn_tree_init</a> </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The instructions in the tree are freed if the Instruction Tree was created with <em>manage</em> set to 1. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf9663d376c0bba8f90ee0602d2733f27"></a><!-- doxytag: member="tree.c::opdis_insn_tree_init" ref="gaf9663d376c0bba8f90ee0602d2733f27" args="(int manage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopdis__tree__base__t.html">opdis_tree_t</a> opdis_insn_tree_init </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>manage</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>manage</em>&nbsp;</td><td>1 if tree should free items on deletion; 0 otherwise. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The allocated tree. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__tree.html#ga3871dfb18bb29c2bdf4d80456fc74a15" title="Free the instruction tree.">opdis_insn_tree_free</a></dd></dl>
<p>This creates a balanced binary tree of instructions keyed by VMA (NOT offset). </p>

</div>
</div>
<a class="anchor" id="ga8a76f83b3101f328cf13fab8cc52ee99"></a><!-- doxytag: member="tree.c::opdis_tree_add" ref="ga8a76f83b3101f328cf13fab8cc52ee99" args="(opdis_tree_t tree, void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int opdis_tree_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopdis__tree__base__t.html">opdis_tree_t</a>&nbsp;</td>
          <td class="paramname"> <em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tree</em>&nbsp;</td><td>The AVL tree. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>The data to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 on if the node was inserted, 0 on if node exists. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__tree.html#ga12e57c33362503697d48546b9cb34fee" title="Insert or overwrite a node in the tree.">opdis_tree_update</a> <a class="el" href="group__tree.html#ga5031ec643ffc62cf06740acac9a30d9c" title="Remove an item from the tree.">opdis_tree_delete</a> </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>If the data already exists in the tree (i.e. the key compare callback returns 0), then the tree is unchanged and this routine returns zero. Use opdis_tree_update to overwrite an existing node. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3083058128d342b87489c70d1592eb3e"></a><!-- doxytag: member="tree.c::opdis_tree_closest" ref="ga3083058128d342b87489c70d1592eb3e" args="(opdis_tree_t tree, void *key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * opdis_tree_closest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopdis__tree__base__t.html">opdis_tree_t</a>&nbsp;</td>
          <td class="paramname"> <em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>key</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tree</em>&nbsp;</td><td>The AVL tree. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>The key of the item to match. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The item that is the closest match, or NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9316ed0eee330a79551d029b40fd1072"></a><!-- doxytag: member="tree.c::opdis_tree_contains" ref="ga9316ed0eee330a79551d029b40fd1072" args="(opdis_tree_t tree, void *key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int opdis_tree_contains </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopdis__tree__base__t.html">opdis_tree_t</a>&nbsp;</td>
          <td class="paramname"> <em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>key</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tree</em>&nbsp;</td><td>The AVL tree. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>The key of the item to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if the item is stored, 0 otherwise. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__tree.html#ga2281a61dffaabd508597bfdf2284d2c1" title="Find data in a tree.">opdis_tree_find</a></dd></dl>
<p>This function returns true (1) if <em>tree</em> contains a node with the given <em>key</em>. This is used instead of opdis_tree_find in trees where the node data (e.g. integers or pointers) could be zero, as the opdis_tree_find return value of NULL for not found will be zero regardless of whether the data is in the tree. </p>

</div>
</div>
<a class="anchor" id="ga2de4dfdef1fd7612a013552bbb482db6"></a><!-- doxytag: member="tree.c::opdis_tree_count" ref="ga2de4dfdef1fd7612a013552bbb482db6" args="(opdis_tree_t tree)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t opdis_tree_count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopdis__tree__base__t.html">opdis_tree_t</a>&nbsp;</td>
          <td class="paramname"> <em>tree</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tree</em>&nbsp;</td><td>The AVL tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of nodes in the tree. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5031ec643ffc62cf06740acac9a30d9c"></a><!-- doxytag: member="tree.c::opdis_tree_delete" ref="ga5031ec643ffc62cf06740acac9a30d9c" args="(opdis_tree_t tree, void *key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int opdis_tree_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopdis__tree__base__t.html">opdis_tree_t</a>&nbsp;</td>
          <td class="paramname"> <em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>key</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tree</em>&nbsp;</td><td>The AVL tree. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>The key of the item to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 on success, 0 on failure. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__tree.html#ga8a76f83b3101f328cf13fab8cc52ee99" title="Insert a node into the tree.">opdis_tree_add</a></dd></dl>
<p>This routine removes the item from the tree and invokes the OPDIS_TREE_FREE_FN to free it. </p>

</div>
</div>
<a class="anchor" id="ga2281a61dffaabd508597bfdf2284d2c1"></a><!-- doxytag: member="tree.c::opdis_tree_find" ref="ga2281a61dffaabd508597bfdf2284d2c1" args="(opdis_tree_t tree, void *key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * opdis_tree_find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopdis__tree__base__t.html">opdis_tree_t</a>&nbsp;</td>
          <td class="paramname"> <em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>key</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tree</em>&nbsp;</td><td>The AVL tree. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>The key of the item to return. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The item stored in the tree or NULL. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__tree.html#ga9316ed0eee330a79551d029b40fd1072" title="Determine if tree contains data.">opdis_tree_contains</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gac6c7ca14f83de83a2b92b709264632d3"></a><!-- doxytag: member="tree.c::opdis_tree_foreach" ref="gac6c7ca14f83de83a2b92b709264632d3" args="(opdis_tree_t tree, OPDIS_TREE_FOREACH_FN fn, void *arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opdis_tree_foreach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopdis__tree__base__t.html">opdis_tree_t</a>&nbsp;</td>
          <td class="paramname"> <em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__tree.html#ga88ee674c3febf1db56ad04a56e54354f">OPDIS_TREE_FOREACH_FN</a>&nbsp;</td>
          <td class="paramname"> <em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>arg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tree</em>&nbsp;</td><td>The AVL tree. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fn</em>&nbsp;</td><td>The callback function to invoke. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>arg</em>&nbsp;</td><td>An optional argument to pass to the callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1366172141006ea2f7059d42a0261350"></a><!-- doxytag: member="tree.c::opdis_tree_free" ref="ga1366172141006ea2f7059d42a0261350" args="(opdis_tree_t tree)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opdis_tree_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopdis__tree__base__t.html">opdis_tree_t</a>&nbsp;</td>
          <td class="paramname"> <em>tree</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tree</em>&nbsp;</td><td>The AVL tree to free. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__tree.html#ga22b76ad142396b401e22715d4587f95a" title="Allocate and initialize for an AVL tree.">opdis_tree_init</a> </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This routine invokes opdis_tree_delete on every node in the tree, then frees the tree itself. When this returns, <em>tree</em> points to an invalid object. </dd></dl>

</div>
</div>
<a class="anchor" id="ga22b76ad142396b401e22715d4587f95a"></a><!-- doxytag: member="tree.c::opdis_tree_init" ref="ga22b76ad142396b401e22715d4587f95a" args="(OPDIS_TREE_KEY_FN key_fn, OPDIS_TREE_CMP_FN cmp_fn, OPDIS_TREE_FREE_FN free_fn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopdis__tree__base__t.html">opdis_tree_t</a> opdis_tree_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__tree.html#ga9180b9d87d36983f5b90a30602be3f5c">OPDIS_TREE_KEY_FN</a>&nbsp;</td>
          <td class="paramname"> <em>key_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__tree.html#gafc668ddef58f0c8b61e1ae4936c5f2b1">OPDIS_TREE_CMP_FN</a>&nbsp;</td>
          <td class="paramname"> <em>cmp_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__tree.html#ga79013cbca91b34050f9955b8c0314c37">OPDIS_TREE_FREE_FN</a>&nbsp;</td>
          <td class="paramname"> <em>free_fn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key_fn</em>&nbsp;</td><td>Callback to use for key retrieval. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cmp_fn</em>&nbsp;</td><td>Callback to use for key comparison. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>free_fn</em>&nbsp;</td><td>Callback to use to free items or NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The allocated binary tree. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__tree.html#ga1366172141006ea2f7059d42a0261350" title="Free an AVL tree.">opdis_tree_free</a> </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>If <em>free_fn</em> is NULL, then items stored in the tree will not be freed when deleted or when the tree is destroyed. </dd></dl>

</div>
</div>
<a class="anchor" id="gae73b720c82a6238b630a4b2e822fbcd6"></a><!-- doxytag: member="tree.c::opdis_tree_next" ref="gae73b720c82a6238b630a4b2e822fbcd6" args="(opdis_tree_t tree, void *key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * opdis_tree_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopdis__tree__base__t.html">opdis_tree_t</a>&nbsp;</td>
          <td class="paramname"> <em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>key</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tree</em>&nbsp;</td><td>The AVL tree. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>The key of the item to match. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The item that is next, or NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="ga12e57c33362503697d48546b9cb34fee"></a><!-- doxytag: member="tree.c::opdis_tree_update" ref="ga12e57c33362503697d48546b9cb34fee" args="(opdis_tree_t tree, void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int opdis_tree_update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopdis__tree__base__t.html">opdis_tree_t</a>&nbsp;</td>
          <td class="paramname"> <em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tree</em>&nbsp;</td><td>The AVL tree. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>The data to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 on success, 0 on failure. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__tree.html#ga8a76f83b3101f328cf13fab8cc52ee99" title="Insert a node into the tree.">opdis_tree_add</a> <a class="el" href="group__tree.html#ga5031ec643ffc62cf06740acac9a30d9c" title="Remove an item from the tree.">opdis_tree_delete</a></dd></dl>
<p>This routine will insert a node into the tree. If the data already exists in the tree (i.e. the key compare callback returns 0), then the data in the tree is freed and replaced. </p>

</div>
</div>
<a class="anchor" id="ga608fad768551cdc684bc101898236b5d"></a><!-- doxytag: member="tree.c::opdis_vma_tree_add" ref="ga608fad768551cdc684bc101898236b5d" args="(opdis_vma_tree_t tree, opdis_vma_t addr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int opdis_vma_tree_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopdis__tree__base__t.html">opdis_vma_tree_t</a>&nbsp;</td>
          <td class="paramname"> <em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga840b1c720d75ade1aa951917191ab1f8">opdis_vma_t</a>&nbsp;</td>
          <td class="paramname"> <em>addr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tree</em>&nbsp;</td><td>The Address Tree. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>addr</em>&nbsp;</td><td>The address to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if address was added, 0 if address exists. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__tree.html#gaf49febac0551efc64e598a22550a27b7" title="Delete an address from the tree.">opdis_vma_tree_delete</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga26e6b33a60e66aa0be5bd4c8c721ab7b"></a><!-- doxytag: member="tree.c::opdis_vma_tree_contains" ref="ga26e6b33a60e66aa0be5bd4c8c721ab7b" args="(opdis_vma_tree_t tree, opdis_vma_t addr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int opdis_vma_tree_contains </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopdis__tree__base__t.html">opdis_vma_tree_t</a>&nbsp;</td>
          <td class="paramname"> <em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga840b1c720d75ade1aa951917191ab1f8">opdis_vma_t</a>&nbsp;</td>
          <td class="paramname"> <em>addr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tree</em>&nbsp;</td><td>The Address Tree. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>addr</em>&nbsp;</td><td>The address to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if the address is in the tree, 0 otherwise. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__tree.html#ga9316ed0eee330a79551d029b40fd1072" title="Determine if tree contains data.">opdis_tree_contains</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaf49febac0551efc64e598a22550a27b7"></a><!-- doxytag: member="tree.c::opdis_vma_tree_delete" ref="gaf49febac0551efc64e598a22550a27b7" args="(opdis_vma_tree_t tree, opdis_vma_t addr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int opdis_vma_tree_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopdis__tree__base__t.html">opdis_vma_tree_t</a>&nbsp;</td>
          <td class="paramname"> <em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga840b1c720d75ade1aa951917191ab1f8">opdis_vma_t</a>&nbsp;</td>
          <td class="paramname"> <em>addr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tree</em>&nbsp;</td><td>The Address Tree. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>addr</em>&nbsp;</td><td>The address to delete. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 on success, 0 on failure. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__tree.html#ga608fad768551cdc684bc101898236b5d" title="Insert an address into the tree.">opdis_vma_tree_add</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga47bf5f8ecf7e79bf90537c801ab7f9a8"></a><!-- doxytag: member="tree.c::opdis_vma_tree_find" ref="ga47bf5f8ecf7e79bf90537c801ab7f9a8" args="(opdis_vma_tree_t tree, opdis_vma_t addr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga840b1c720d75ade1aa951917191ab1f8">opdis_vma_t</a> opdis_vma_tree_find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopdis__tree__base__t.html">opdis_vma_tree_t</a>&nbsp;</td>
          <td class="paramname"> <em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga840b1c720d75ade1aa951917191ab1f8">opdis_vma_t</a>&nbsp;</td>
          <td class="paramname"> <em>addr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tree</em>&nbsp;</td><td>The Address Tree. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>addr</em>&nbsp;</td><td>The address to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The address or OPDIS_INVALID_ADDR. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__tree.html#ga2281a61dffaabd508597bfdf2284d2c1" title="Find data in a tree.">opdis_tree_find</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gae69a7b66b8f3ff62c201c09e325c23aa"></a><!-- doxytag: member="tree.c::opdis_vma_tree_foreach" ref="gae69a7b66b8f3ff62c201c09e325c23aa" args="(opdis_vma_tree_t tree, OPDIS_ADDR_TREE_FOREACH_FN fn, void *arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opdis_vma_tree_foreach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopdis__tree__base__t.html">opdis_vma_tree_t</a>&nbsp;</td>
          <td class="paramname"> <em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__tree.html#ga3527a2610bb81bb8ce808ce8d3504024">OPDIS_ADDR_TREE_FOREACH_FN</a>&nbsp;</td>
          <td class="paramname"> <em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>arg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tree</em>&nbsp;</td><td>The Address Tree. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fn</em>&nbsp;</td><td>The callback to invoke for each address. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>arg</em>&nbsp;</td><td>An optional argument to pass to the callback function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga794c82fb6567c84f30b99014f8934013"></a><!-- doxytag: member="tree.c::opdis_vma_tree_free" ref="ga794c82fb6567c84f30b99014f8934013" args="(opdis_vma_tree_t tree)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opdis_vma_tree_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopdis__tree__base__t.html">opdis_vma_tree_t</a>&nbsp;</td>
          <td class="paramname"> <em>tree</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tree</em>&nbsp;</td><td>The Address Tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__tree.html#gacf3ae7b1e576bc22fe5d0500b6255103" title="Allocate an Address Tree.">opdis_vma_tree_init</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gacf3ae7b1e576bc22fe5d0500b6255103"></a><!-- doxytag: member="tree.c::opdis_vma_tree_init" ref="gacf3ae7b1e576bc22fe5d0500b6255103" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopdis__tree__base__t.html">opdis_vma_tree_t</a> opdis_vma_tree_init </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>The allocated tree. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__tree.html#ga794c82fb6567c84f30b99014f8934013" title="Free the address tree.">opdis_vma_tree_free</a></dd></dl>
<p>This creates a balanced binary tree of addresses. In this tree, the key is the same as the data: its primary use is to keep track of addresses which have been visited. </p>

</div>
</div>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Sat Mar 6 18:51:18 2010 for Opdis Disassembly Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
