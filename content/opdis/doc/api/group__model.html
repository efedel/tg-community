<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Opdis Disassembly Library: Data Model</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Data Model</h1>
<p>Data Model for disassembled objects.  
<a href="#_details">More...</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopdis__reg__t.html">opdis_reg_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">CPU Register operand.  <a href="structopdis__reg__t.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopdis__abs__addr__t.html">opdis_abs_addr_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An absolute address operand.  <a href="structopdis__abs__addr__t.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopdis__addr__expr__t.html">opdis_addr_expr_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An address expression operand.  <a href="structopdis__addr__expr__t.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopdis__op__t.html">opdis_op_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Operand object.  <a href="structopdis__op__t.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopdis__insn__t.html">opdis_insn_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Instruction object.  <a href="structopdis__insn__t.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__model.html#ga28daebb5c77a83733a8a25d048770729">opdis_op_cat_t</a> { <br/>
&nbsp;&nbsp;<a class="el" href="group__model.html#ga28daebb5c77a83733a8a25d048770729abe08409f1ffa17c2195073a760056e07">opdis_op_cat_unknown</a>, 
<a class="el" href="group__model.html#ga28daebb5c77a83733a8a25d048770729a3fc3bf472fc34d332ba00d37b28edd51">opdis_op_cat_register</a>, 
<a class="el" href="group__model.html#ga28daebb5c77a83733a8a25d048770729acfc57cc8ba89fd85da6402774db986bc">opdis_op_cat_immediate</a>, 
<a class="el" href="group__model.html#ga28daebb5c77a83733a8a25d048770729af6549aec4736930427d03a11d3ce85c1">opdis_op_cat_absolute</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__model.html#ga28daebb5c77a83733a8a25d048770729a42fbf2d9c2869245ccb9b09158ba706a">opdis_op_cat_expr</a>
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>The <em>category</em> of an operand. </p>
 <a href="group__model.html#ga28daebb5c77a83733a8a25d048770729">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__model.html#ga5ac390fb588453761de58abb3c0e268a">opdis_op_flag_t</a> { <br/>
&nbsp;&nbsp;<a class="el" href="group__model.html#ga5ac390fb588453761de58abb3c0e268aaa12e23871d56e8a981851c2e02c72568">opdis_op_flag_none</a> =  0, 
<a class="el" href="group__model.html#ga5ac390fb588453761de58abb3c0e268aae6e9457d9a989cff3f328321dfb06736">opdis_op_flag_r</a> =  1, 
<a class="el" href="group__model.html#ga5ac390fb588453761de58abb3c0e268aac7d9cc4305acf9feea5adc62bef13ebe">opdis_op_flag_w</a> =  2, 
<a class="el" href="group__model.html#ga5ac390fb588453761de58abb3c0e268aa7d3130481f001b4160ab6858f0f6f1c2">opdis_op_flag_x</a> =  4, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__model.html#ga5ac390fb588453761de58abb3c0e268aa5a8cf1e35309e2d12b51b3712bc0df69">opdis_op_flag_signed</a> =  8, 
<a class="el" href="group__model.html#ga5ac390fb588453761de58abb3c0e268aaace4ad9d894c9fb898191a516b2fdea7">opdis_op_flag_address</a> =  16, 
<a class="el" href="group__model.html#ga5ac390fb588453761de58abb3c0e268aa448e445b38869ae34df437d63fe67760">opdis_op_flag_indirect</a> =  32
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Flags applied to an operand. </p>
 <a href="group__model.html#ga5ac390fb588453761de58abb3c0e268a">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__model.html#gab3e66fe59b04d4eef45728bd9922d573">opdis_insn_subset_t</a> { <br/>
&nbsp;&nbsp;<a class="el" href="group__model.html#gab3e66fe59b04d4eef45728bd9922d573a3e655c97d6a45ab5952729eb740a7723">opdis_insn_subset_gen</a>, 
<a class="el" href="group__model.html#gab3e66fe59b04d4eef45728bd9922d573ac83c57ada475940d5af1ae0aacaba872">opdis_insn_subset_fpu</a>, 
<a class="el" href="group__model.html#gab3e66fe59b04d4eef45728bd9922d573ab9b6c105c6cdcc10e27d0d2fff178ecf">opdis_insn_subset_gpu</a>, 
<a class="el" href="group__model.html#gab3e66fe59b04d4eef45728bd9922d573a96900ff34ef8fb6480a0a934968fccb5">opdis_insn_subset_simd</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__model.html#gab3e66fe59b04d4eef45728bd9922d573a0067ab941e35514f1ea1ab9e20a6e0b4">opdis_insn_subset_vm</a>
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>The <em>subset</em> of an ISA that the instruction belongs to. </p>
 <a href="group__model.html#gab3e66fe59b04d4eef45728bd9922d573">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__model.html#ga01216fda1b5bcd2337106b78d6fa3411">opdis_insn_cat_t</a> { <br/>
&nbsp;&nbsp;<a class="el" href="group__model.html#ga01216fda1b5bcd2337106b78d6fa3411ae580691b2062852a47d94d5674cfb97c">opdis_insn_cat_unknown</a>, 
<a class="el" href="group__model.html#ga01216fda1b5bcd2337106b78d6fa3411a8cdd463b0554f72c34f0293b200cc4a7">opdis_insn_cat_cflow</a>, 
<a class="el" href="group__model.html#ga01216fda1b5bcd2337106b78d6fa3411a89cd76437838cd6c6370739e6a8f88c7">opdis_insn_cat_stack</a>, 
<a class="el" href="group__model.html#ga01216fda1b5bcd2337106b78d6fa3411a04a72773a6712bb419730f8b9a1ec28c">opdis_insn_cat_lost</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__model.html#ga01216fda1b5bcd2337106b78d6fa3411ad69608d8f0d7898810479d6632a4b1f9">opdis_insn_cat_test</a>, 
<a class="el" href="group__model.html#ga01216fda1b5bcd2337106b78d6fa3411a128b9d9db646f487d7ae93c3c4256f1d">opdis_insn_cat_math</a>, 
<a class="el" href="group__model.html#ga01216fda1b5bcd2337106b78d6fa3411a065e57e1e2659456ec83baa8297a6da1">opdis_insn_cat_bit</a>, 
<a class="el" href="group__model.html#ga01216fda1b5bcd2337106b78d6fa3411aadb2a5aa11013f45c5625a306bcfebb2">opdis_insn_cat_io</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__model.html#ga01216fda1b5bcd2337106b78d6fa3411a3e76b839ae62f089d82e8885e1845a40">opdis_insn_cat_trap</a>, 
<a class="el" href="group__model.html#ga01216fda1b5bcd2337106b78d6fa3411a65190c714821b66894646f47e797b7c7">opdis_insn_cat_priv</a>, 
<a class="el" href="group__model.html#ga01216fda1b5bcd2337106b78d6fa3411aa2a9066465c2f5b3efee21f5d66e24f0">opdis_insn_cat_nop</a>
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>The <em>category</em> of an instruction. </p>
 <a href="group__model.html#ga01216fda1b5bcd2337106b78d6fa3411">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__model.html#ga65b1d22eb012f92c4ea6cd4ec60a79c7">opdis_cflow_flag_t</a> { <br/>
&nbsp;&nbsp;<a class="el" href="group__model.html#ga65b1d22eb012f92c4ea6cd4ec60a79c7a08f836c14da0102b00e7eb16ce177e2b">opdis_cflow_flag_none</a> = 0, 
<a class="el" href="group__model.html#ga65b1d22eb012f92c4ea6cd4ec60a79c7a7f6ce3512eeeb1f7ae31312093ec6d53">opdis_cflow_flag_call</a> = 1, 
<a class="el" href="group__model.html#ga65b1d22eb012f92c4ea6cd4ec60a79c7a04ac06c641a11f0f7b7eff51cbf30240">opdis_cflow_flag_callcc</a> = 2, 
<a class="el" href="group__model.html#ga65b1d22eb012f92c4ea6cd4ec60a79c7ab7c7162b22ce85125c565256d3b02db1">opdis_cflow_flag_jmp</a> = 4, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__model.html#ga65b1d22eb012f92c4ea6cd4ec60a79c7aee6601fc3faf9e82c9edf35ae04b2d7e">opdis_cflow_flag_jmpcc</a> = 8, 
<a class="el" href="group__model.html#ga65b1d22eb012f92c4ea6cd4ec60a79c7a79513228f151bb7ef3ec8683b139e501">opdis_cflow_flag_ret</a> = 16
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Details of the control flow instruction. </p>
 <a href="group__model.html#ga65b1d22eb012f92c4ea6cd4ec60a79c7">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__model.html#gaae467dfe6fa63d243f020741e7345762">opdis_stack_flag_t</a> { <br/>
&nbsp;&nbsp;<a class="el" href="group__model.html#gaae467dfe6fa63d243f020741e7345762a03c0ef0c06c56b2e6d5b1453afe515e4">opdis_stack_flag_none</a> = 0, 
<a class="el" href="group__model.html#gaae467dfe6fa63d243f020741e7345762a55d2cfb01453e692d4561ebbd63f2e23">opdis_stack_flag_push</a> = 1, 
<a class="el" href="group__model.html#gaae467dfe6fa63d243f020741e7345762a2e0515c8cb26af8c208a0d1968472e76">opdis_stack_flag_pop</a> = 2, 
<a class="el" href="group__model.html#gaae467dfe6fa63d243f020741e7345762ab1858bb31629a7ff17b8d1ac7d0e27a3">opdis_stack_flag_frame</a> = 4, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__model.html#gaae467dfe6fa63d243f020741e7345762ab801f9904bec2d2e431b215e94e36476">opdis_stack_flag_unframe</a> = 8
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Details of the instruction. </p>
 <a href="group__model.html#gaae467dfe6fa63d243f020741e7345762">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__model.html#ga5b0730a59b760cc42a5137e6c1b06c2c">opdis_bit_flag_t</a> { <br/>
&nbsp;&nbsp;<a class="el" href="group__model.html#ga5b0730a59b760cc42a5137e6c1b06c2ca9b7d976398cfef39744fe6f613120107">opdis_bit_flag_none</a> = 0, 
<a class="el" href="group__model.html#ga5b0730a59b760cc42a5137e6c1b06c2ca65627ec82b59b2849390bf364862e1a5">opdis_bit_flag_and</a> = 1, 
<a class="el" href="group__model.html#ga5b0730a59b760cc42a5137e6c1b06c2cad12f90ee70f587b082c97cd27a09c008">opdis_bit_flag_or</a> = 2, 
<a class="el" href="group__model.html#ga5b0730a59b760cc42a5137e6c1b06c2ca912c2bedc680cd184d96aaacb6a85bf6">opdis_bit_flag_xor</a> = 4, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__model.html#ga5b0730a59b760cc42a5137e6c1b06c2caf61342d45c8e8e0c925b0c7785f69dd7">opdis_bit_flag_not</a> = 8, 
<a class="el" href="group__model.html#ga5b0730a59b760cc42a5137e6c1b06c2ca904c4d381c31c9569b8b965cbdcba1fb">opdis_bit_flag_lsl</a> = 16, 
<a class="el" href="group__model.html#ga5b0730a59b760cc42a5137e6c1b06c2cae3cd03231309fa38cb33e9d514409d97">opdis_bit_flag_lsr</a> = 32, 
<a class="el" href="group__model.html#ga5b0730a59b760cc42a5137e6c1b06c2cad4444ef8aa5096a594582c4b8f72e46c">opdis_bit_flag_asl</a> = 64, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__model.html#ga5b0730a59b760cc42a5137e6c1b06c2caf39eb321a9a92da4eb07db651ea09712">opdis_bit_flag_asr</a> = 128, 
<a class="el" href="group__model.html#ga5b0730a59b760cc42a5137e6c1b06c2caef3688fe4f61f7df610eb49f3d433960">opdis_bit_flag_rol</a> = 256, 
<a class="el" href="group__model.html#ga5b0730a59b760cc42a5137e6c1b06c2cabae0c89b17f47c00abe643331dbccda9">opdis_bit_flag_ror</a> = 512, 
<a class="el" href="group__model.html#ga5b0730a59b760cc42a5137e6c1b06c2cac2602381e6cd7a2a8a8a003f7e2454c1">opdis_bit_flag_rcl</a> = 1024, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__model.html#ga5b0730a59b760cc42a5137e6c1b06c2ca9aff8e14e6f90b39fd00436408f4e348">opdis_bit_flag_rcr</a> = 2048
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Details of the instruction. </p>
 <a href="group__model.html#ga5b0730a59b760cc42a5137e6c1b06c2c">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__model.html#ga41baa012ac145f47d2b7d4be4b78bd49">opdis_io_flag_t</a> { <a class="el" href="group__model.html#ga41baa012ac145f47d2b7d4be4b78bd49a24dd27c0987cf4b53686a1aa12229286">opdis_io_flag_none</a> = 0, 
<a class="el" href="group__model.html#ga41baa012ac145f47d2b7d4be4b78bd49a7dad8577c5bbd8fc4c370dd41d16f0c7">opdis_io_flag_in</a> = 1, 
<a class="el" href="group__model.html#ga41baa012ac145f47d2b7d4be4b78bd49a4764e885449902b18ef0a8473a71f166">opdis_io_flag_out</a> = 2
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Details of the instruction. </p>
 <a href="group__model.html#ga41baa012ac145f47d2b7d4be4b78bd49">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__model.html#ga72a00cd036e505d7c7538fc4a4427549">opdis_addr_expr_elem_t</a> { <br/>
&nbsp;&nbsp;<a class="el" href="group__model.html#ga72a00cd036e505d7c7538fc4a4427549a7da50c024e16c54652bd2f69c7ac9f38">opdis_addr_expr_base</a> =  1, 
<a class="el" href="group__model.html#ga72a00cd036e505d7c7538fc4a4427549a5ac340b30bda9fd53320d59317bfec02">opdis_addr_expr_index</a> =  2, 
<a class="el" href="group__model.html#ga72a00cd036e505d7c7538fc4a4427549a945e4157c0d7217f1b31b024669bde78">opdis_addr_expr_disp</a> =  4, 
<a class="el" href="group__model.html#ga72a00cd036e505d7c7538fc4a4427549a89c104763523f580698ecacf44ab40b7">opdis_addr_expr_disp_u</a> =  8, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__model.html#ga72a00cd036e505d7c7538fc4a4427549ad55c8bf635d06c03cd3ad3f19f1be866">opdis_addr_expr_disp_s</a> =  16, 
<a class="el" href="group__model.html#ga72a00cd036e505d7c7538fc4a4427549a85ba48d151105995697c4d33495e357b">opdis_addr_expr_disp_abs</a> =  32
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Elements present in an address expression. </p>
 <a href="group__model.html#ga72a00cd036e505d7c7538fc4a4427549">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__model.html#gaeae037ecabe7c86e3abd9bd17eb2b0d5">opdis_addr_expr_shift_t</a> { <br/>
&nbsp;&nbsp;<a class="el" href="group__model.html#gaeae037ecabe7c86e3abd9bd17eb2b0d5aac06bf0fa37aaf0002dae24a7839a22d">opdis_addr_expr_lsl</a>, 
<a class="el" href="group__model.html#gaeae037ecabe7c86e3abd9bd17eb2b0d5a9128ed5498175b29c1bd9b53dcb251ad">opdis_addr_expr_lsr</a>, 
<a class="el" href="group__model.html#gaeae037ecabe7c86e3abd9bd17eb2b0d5a020bc1023e95ba05085e41bae8ad9cab">opdis_addr_expr_asl</a>, 
<a class="el" href="group__model.html#gaeae037ecabe7c86e3abd9bd17eb2b0d5a299405e00d612b2a9e30418cbff12a6a">opdis_addr_expr_ror</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__model.html#gaeae037ecabe7c86e3abd9bd17eb2b0d5a9a7a4d0ca41df501192c7a12d2da55e4">opdis_addr_expr_rrx</a>
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Type of shift operation used in address expression. </p>
 <a href="group__model.html#gaeae037ecabe7c86e3abd9bd17eb2b0d5">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structopdis__insn__t.html">opdis_insn_t</a> *LIBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__model.html#ga4992e794ac0a88d4f80f9f1475e8f175">opdis_insn_alloc</a> (<a class="el" href="types_8h.html#abd14f9464752cb16147541a663f70797">opdis_off_t</a> num_operands)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate an instruction object and initialize its contents to zero.  <a href="#ga4992e794ac0a88d4f80f9f1475e8f175"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structopdis__insn__t.html">opdis_insn_t</a> *LIBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__model.html#gacd2254417c9ce98649d250504a3d9e5c">opdis_insn_alloc_fixed</a> (size_t ascii_sz, size_t mnemonic_sz, size_t num_operands, size_t op_ascii_sz)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a fixed-size instruction object for use as a buffer.  <a href="#gacd2254417c9ce98649d250504a3d9e5c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structopdis__insn__t.html">opdis_insn_t</a> *LIBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__model.html#ga6c019dce7557b07130f039ffbbdfba0f">opdis_insn_dupe</a> (const <a class="el" href="structopdis__insn__t.html">opdis_insn_t</a> *insn)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Duplicate an instruction object.  <a href="#ga6c019dce7557b07130f039ffbbdfba0f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void LIBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__model.html#ga89a333b915634cb7f779bb113e385b93">opdis_insn_clear</a> (<a class="el" href="structopdis__insn__t.html">opdis_insn_t</a> *insn)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear the contents of an instruction object.  <a href="#ga89a333b915634cb7f779bb113e385b93"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void LIBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__model.html#gada22f42ccc5979fe1f93f90b4cd45f45">opdis_insn_free</a> (<a class="el" href="structopdis__insn__t.html">opdis_insn_t</a> *insn)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free an allocated instruction object.  <a href="#gada22f42ccc5979fe1f93f90b4cd45f45"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void LIBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__model.html#gaa6c2f53403d0b276d668a4ef4b87b8dd">opdis_insn_set_ascii</a> (<a class="el" href="structopdis__insn__t.html">opdis_insn_t</a> *i, const char *ascii)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the <em>ascii</em> field of an instruction.  <a href="#gaa6c2f53403d0b276d668a4ef4b87b8dd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void LIBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__model.html#gad86b504bebfefd17efe68d602534c59a">opdis_insn_set_mnemonic</a> (<a class="el" href="structopdis__insn__t.html">opdis_insn_t</a> *i, const char *mnemonic)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the <em>mnemonic</em> field of an instruction.  <a href="#gad86b504bebfefd17efe68d602534c59a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void LIBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__model.html#ga751521f2fb33dac1f6d3e8d7d68367cd">opdis_insn_add_prefix</a> (<a class="el" href="structopdis__insn__t.html">opdis_insn_t</a> *i, const char *prefix)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append a string to the <em>prefix</em> field.  <a href="#ga751521f2fb33dac1f6d3e8d7d68367cd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void LIBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__model.html#ga5f0a91fdadb0c8ba96431f120a3e7332">opdis_insn_add_comment</a> (<a class="el" href="structopdis__insn__t.html">opdis_insn_t</a> *i, const char *cmt)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append a string to the <em>comment</em> field.  <a href="#ga5f0a91fdadb0c8ba96431f120a3e7332"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int LIBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__model.html#ga5a1dfde629d11b74910b16c4d8bcefc1">opdis_insn_add_operand</a> (<a class="el" href="structopdis__insn__t.html">opdis_insn_t</a> *i, <a class="el" href="structopdis__op__t.html">opdis_op_t</a> *op)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add an operand to an instruction.  <a href="#ga5a1dfde629d11b74910b16c4d8bcefc1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structopdis__op__t.html">opdis_op_t</a> *LIBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__model.html#ga075856ad59c43be9a86aec5ba5d992fd">opdis_insn_next_avail_op</a> (<a class="el" href="structopdis__insn__t.html">opdis_insn_t</a> *i)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return next available allocated operand.  <a href="#ga075856ad59c43be9a86aec5ba5d992fd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int LIBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__model.html#ga0e3d911601d06794b5c9fc2b8087c2e8">opdis_insn_is_branch</a> (<a class="el" href="structopdis__insn__t.html">opdis_insn_t</a> *i)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine if the instruction has a branch target operand.  <a href="#ga0e3d911601d06794b5c9fc2b8087c2e8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int LIBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__model.html#gae18f36b4e3e68e5448985d4a630252c8">opdis_insn_fallthrough</a> (<a class="el" href="structopdis__insn__t.html">opdis_insn_t</a> *i)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine if the execution falls through to the next instruction.  <a href="#gae18f36b4e3e68e5448985d4a630252c8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int LIBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__model.html#ga371d9a1b5d5d7efc1f4d5fb5deeeafba">opdis_insn_isa_str</a> (const <a class="el" href="structopdis__insn__t.html">opdis_insn_t</a> *insn, char *buf, int buf_len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate a string representation of instruction isa field.  <a href="#ga371d9a1b5d5d7efc1f4d5fb5deeeafba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int LIBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__model.html#gad5f349120a4b3813de59cbc03a158d1e">opdis_insn_cat_str</a> (const <a class="el" href="structopdis__insn__t.html">opdis_insn_t</a> *insn, char *buf, int buf_len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate a string representation of instruction category field.  <a href="#gad5f349120a4b3813de59cbc03a158d1e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int LIBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__model.html#gaf686ee40be5c7c25f265f22c974c98f2">opdis_insn_flags_str</a> (const <a class="el" href="structopdis__insn__t.html">opdis_insn_t</a> *insn, char *buf, int buf_len, const char *delim)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate a string representation of instruction flags field.  <a href="#gaf686ee40be5c7c25f265f22c974c98f2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structopdis__op__t.html">opdis_op_t</a> *LIBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__model.html#gaea56a07ea3b2720ef99c69e77b2dce39">opdis_op_alloc</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate an operand object.  <a href="#gaea56a07ea3b2720ef99c69e77b2dce39"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structopdis__op__t.html">opdis_op_t</a> *LIBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__model.html#ga215c544ed96df3ebf1617806049ab51f">opdis_op_alloc_fixed</a> (size_t ascii_sz)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a fixed-size operand object for use as a buffer.  <a href="#ga215c544ed96df3ebf1617806049ab51f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structopdis__op__t.html">opdis_op_t</a> *LIBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__model.html#ga57fc4036087f36ac9a0db74573d03645">opdis_op_dupe</a> (<a class="el" href="structopdis__op__t.html">opdis_op_t</a> *op)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Duplicate an operand object.  <a href="#ga57fc4036087f36ac9a0db74573d03645"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void LIBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__model.html#ga8f58c4353bae9c990c6ce115bc7e1197">opdis_op_clear</a> (<a class="el" href="structopdis__op__t.html">opdis_op_t</a> *op)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear the contents of an operand object.  <a href="#ga8f58c4353bae9c990c6ce115bc7e1197"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void LIBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__model.html#ga24074cb8c02c91af679cf200f3c8f6a0">opdis_op_free</a> (<a class="el" href="structopdis__op__t.html">opdis_op_t</a> *op)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free an allocated operand object.  <a href="#ga24074cb8c02c91af679cf200f3c8f6a0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void LIBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__model.html#gab02d492abf8059dbbd5083c4139e6712">opdis_op_set_ascii</a> (<a class="el" href="structopdis__op__t.html">opdis_op_t</a> *op, const char *ascii)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the <em>ascii</em> field of an operand.  <a href="#gab02d492abf8059dbbd5083c4139e6712"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int LIBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__model.html#gaff49a0e6824359e6212eac50853511e7">opdis_op_cat_str</a> (const <a class="el" href="structopdis__op__t.html">opdis_op_t</a> *op, char *buf, int buf_len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate a string representation of operand category field.  <a href="#gaff49a0e6824359e6212eac50853511e7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int LIBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__model.html#ga6c8eb935b4778836b95cac7b39a41579">opdis_op_flags_str</a> (const <a class="el" href="structopdis__op__t.html">opdis_op_t</a> *op, char *buf, int buf_len, const char *delim)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate a string representation of operand flags field.  <a href="#ga6c8eb935b4778836b95cac7b39a41579"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int LIBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__model.html#gadba3bfc5784822f55c28fef293a454d3">opdis_reg_flags_str</a> (const <a class="el" href="structopdis__reg__t.html">opdis_reg_t</a> *reg, char *buf, int buf_len, const char *delim)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate a string representation of register flags field.  <a href="#gadba3bfc5784822f55c28fef293a454d3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int LIBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__model.html#ga5b3db474b454e0b4f54fe05d7cc69930">opdis_addr_expr_shift_str</a> (const <a class="el" href="structopdis__addr__expr__t.html">opdis_addr_expr_t</a> *exp, char *buf, int buf_len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate a string representation of addr expression shift field.  <a href="#ga5b3db474b454e0b4f54fe05d7cc69930"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Data Model for disassembled objects. </p>
<p>The <b>libopdis</b> data model consist of objects for instructions, operands, and operand values. </p>
<p>Each <a class="el" href="structopdis__insn__t.html">instruction </a> consists of <b>address</b> details (vma, offset, size, bytes), zero or more <b>prefixes</b>, a <br/>
 mnemonic for the machine opcode, and zero or more <b>operands</b>. Each <a class="el" href="structopdis__op__t.html">operand </a> consists of a <b>value</b> which may be a <a class="el" href="structopdis__reg__t.html">register </a>, <a class="el" href="structopdis__abs__addr__t.html">absolute address </a>, <a class="el" href="structopdis__addr__expr__t.html">address expression </a>, or immediate value. </p>
<p>Instruction, operand, and register objects all have an <b>ascii</b> attribute that contains the raw output from <b>libopcodes</b> for this object. Note that <b>libopcodes</b> attempts to format its output for objdump, so there may be trailing whitespace in the <b>ascii</b> fields. </p>
<p>Instruction and operand objects have a <b>category</b> attribute that determines the broad type or category of the instruction (e.g. is it a control flow or stack operation) or operand (e.g. is it a register or immediate value). </p>
<p>Insructions, operands, and registers also have a <b>flags</b> attribute that contains additional information. For instructions, this will consist of a more detailed operation type (e.g. jump vs call). For operands, this will contain usage info (e.g. is the operand an address, is the operand read or written, etc). For registers, this will contain general usage info about the register (e.g. is it general-purpose, it is a stack pointer, etc). </p>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="ga72a00cd036e505d7c7538fc4a4427549"></a><!-- doxytag: member="model.h::opdis_addr_expr_elem_t" ref="ga72a00cd036e505d7c7538fc4a4427549" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__model.html#ga72a00cd036e505d7c7538fc4a4427549">opdis_addr_expr_elem_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Elements present in an address expression. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="structopdis__addr__expr__t.html" title="An address expression operand.">opdis_addr_expr_t</a> </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Scale factor is always present; it defaults to 1. </dd></dl>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ga72a00cd036e505d7c7538fc4a4427549a7da50c024e16c54652bd2f69c7ac9f38"></a><!-- doxytag: member="opdis_addr_expr_base" ref="ga72a00cd036e505d7c7538fc4a4427549a7da50c024e16c54652bd2f69c7ac9f38" args="" -->opdis_addr_expr_base</em>&nbsp;</td><td>
<p>Base register </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ga72a00cd036e505d7c7538fc4a4427549a5ac340b30bda9fd53320d59317bfec02"></a><!-- doxytag: member="opdis_addr_expr_index" ref="ga72a00cd036e505d7c7538fc4a4427549a5ac340b30bda9fd53320d59317bfec02" args="" -->opdis_addr_expr_index</em>&nbsp;</td><td>
<p>Index register </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ga72a00cd036e505d7c7538fc4a4427549a945e4157c0d7217f1b31b024669bde78"></a><!-- doxytag: member="opdis_addr_expr_disp" ref="ga72a00cd036e505d7c7538fc4a4427549a945e4157c0d7217f1b31b024669bde78" args="" -->opdis_addr_expr_disp</em>&nbsp;</td><td>
<p>Displacement </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ga72a00cd036e505d7c7538fc4a4427549a89c104763523f580698ecacf44ab40b7"></a><!-- doxytag: member="opdis_addr_expr_disp_u" ref="ga72a00cd036e505d7c7538fc4a4427549a89c104763523f580698ecacf44ab40b7" args="" -->opdis_addr_expr_disp_u</em>&nbsp;</td><td>
<p>Unsigned disp </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ga72a00cd036e505d7c7538fc4a4427549ad55c8bf635d06c03cd3ad3f19f1be866"></a><!-- doxytag: member="opdis_addr_expr_disp_s" ref="ga72a00cd036e505d7c7538fc4a4427549ad55c8bf635d06c03cd3ad3f19f1be866" args="" -->opdis_addr_expr_disp_s</em>&nbsp;</td><td>
<p>Signed disp </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ga72a00cd036e505d7c7538fc4a4427549a85ba48d151105995697c4d33495e357b"></a><!-- doxytag: member="opdis_addr_expr_disp_abs" ref="ga72a00cd036e505d7c7538fc4a4427549a85ba48d151105995697c4d33495e357b" args="" -->opdis_addr_expr_disp_abs</em>&nbsp;</td><td>
<p>Absolute addr disp </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="gaeae037ecabe7c86e3abd9bd17eb2b0d5"></a><!-- doxytag: member="model.h::opdis_addr_expr_shift_t" ref="gaeae037ecabe7c86e3abd9bd17eb2b0d5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__model.html#gaeae037ecabe7c86e3abd9bd17eb2b0d5">opdis_addr_expr_shift_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Type of shift operation used in address expression. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="structopdis__addr__expr__t.html" title="An address expression operand.">opdis_addr_expr_t</a> </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>These only apply to ARM; x86 is always ASL. </dd></dl>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gaeae037ecabe7c86e3abd9bd17eb2b0d5aac06bf0fa37aaf0002dae24a7839a22d"></a><!-- doxytag: member="opdis_addr_expr_lsl" ref="gaeae037ecabe7c86e3abd9bd17eb2b0d5aac06bf0fa37aaf0002dae24a7839a22d" args="" -->opdis_addr_expr_lsl</em>&nbsp;</td><td>
<p>Logical shift left </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gaeae037ecabe7c86e3abd9bd17eb2b0d5a9128ed5498175b29c1bd9b53dcb251ad"></a><!-- doxytag: member="opdis_addr_expr_lsr" ref="gaeae037ecabe7c86e3abd9bd17eb2b0d5a9128ed5498175b29c1bd9b53dcb251ad" args="" -->opdis_addr_expr_lsr</em>&nbsp;</td><td>
<p>Logical shift right </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gaeae037ecabe7c86e3abd9bd17eb2b0d5a020bc1023e95ba05085e41bae8ad9cab"></a><!-- doxytag: member="opdis_addr_expr_asl" ref="gaeae037ecabe7c86e3abd9bd17eb2b0d5a020bc1023e95ba05085e41bae8ad9cab" args="" -->opdis_addr_expr_asl</em>&nbsp;</td><td>
<p>Arithmetic shift left </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gaeae037ecabe7c86e3abd9bd17eb2b0d5a299405e00d612b2a9e30418cbff12a6a"></a><!-- doxytag: member="opdis_addr_expr_ror" ref="gaeae037ecabe7c86e3abd9bd17eb2b0d5a299405e00d612b2a9e30418cbff12a6a" args="" -->opdis_addr_expr_ror</em>&nbsp;</td><td>
<p>Rotate right </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gaeae037ecabe7c86e3abd9bd17eb2b0d5a9a7a4d0ca41df501192c7a12d2da55e4"></a><!-- doxytag: member="opdis_addr_expr_rrx" ref="gaeae037ecabe7c86e3abd9bd17eb2b0d5a9a7a4d0ca41df501192c7a12d2da55e4" args="" -->opdis_addr_expr_rrx</em>&nbsp;</td><td>
<p>Rotate right with carry </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5b0730a59b760cc42a5137e6c1b06c2c"></a><!-- doxytag: member="metadata.h::opdis_bit_flag_t" ref="ga5b0730a59b760cc42a5137e6c1b06c2c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__model.html#ga5b0730a59b760cc42a5137e6c1b06c2c">opdis_bit_flag_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Details of the instruction. </p>
<p>These flags encode specific information about the instructions: is it a shift or rotate (and is the carry flag significant), is it an AND/OR/XOR/NOT operation, etc. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>It is the responsibility of the architecture-specific decoder to enure that the correct flags set. A missing flag does not necessarily mean that the flag does not apply, but may indicate that the decoder does not fully support the instruction. </dd></dl>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ga5b0730a59b760cc42a5137e6c1b06c2ca9b7d976398cfef39744fe6f613120107"></a><!-- doxytag: member="opdis_bit_flag_none" ref="ga5b0730a59b760cc42a5137e6c1b06c2ca9b7d976398cfef39744fe6f613120107" args="" -->opdis_bit_flag_none</em>&nbsp;</td><td>
<p>No flags </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ga5b0730a59b760cc42a5137e6c1b06c2ca65627ec82b59b2849390bf364862e1a5"></a><!-- doxytag: member="opdis_bit_flag_and" ref="ga5b0730a59b760cc42a5137e6c1b06c2ca65627ec82b59b2849390bf364862e1a5" args="" -->opdis_bit_flag_and</em>&nbsp;</td><td>
<p>bitwise AND </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ga5b0730a59b760cc42a5137e6c1b06c2cad12f90ee70f587b082c97cd27a09c008"></a><!-- doxytag: member="opdis_bit_flag_or" ref="ga5b0730a59b760cc42a5137e6c1b06c2cad12f90ee70f587b082c97cd27a09c008" args="" -->opdis_bit_flag_or</em>&nbsp;</td><td>
<p>bitwise OR </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ga5b0730a59b760cc42a5137e6c1b06c2ca912c2bedc680cd184d96aaacb6a85bf6"></a><!-- doxytag: member="opdis_bit_flag_xor" ref="ga5b0730a59b760cc42a5137e6c1b06c2ca912c2bedc680cd184d96aaacb6a85bf6" args="" -->opdis_bit_flag_xor</em>&nbsp;</td><td>
<p>bitwise XOR </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ga5b0730a59b760cc42a5137e6c1b06c2caf61342d45c8e8e0c925b0c7785f69dd7"></a><!-- doxytag: member="opdis_bit_flag_not" ref="ga5b0730a59b760cc42a5137e6c1b06c2caf61342d45c8e8e0c925b0c7785f69dd7" args="" -->opdis_bit_flag_not</em>&nbsp;</td><td>
<p>bitwise NOT </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ga5b0730a59b760cc42a5137e6c1b06c2ca904c4d381c31c9569b8b965cbdcba1fb"></a><!-- doxytag: member="opdis_bit_flag_lsl" ref="ga5b0730a59b760cc42a5137e6c1b06c2ca904c4d381c31c9569b8b965cbdcba1fb" args="" -->opdis_bit_flag_lsl</em>&nbsp;</td><td>
<p>Logical shift left </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ga5b0730a59b760cc42a5137e6c1b06c2cae3cd03231309fa38cb33e9d514409d97"></a><!-- doxytag: member="opdis_bit_flag_lsr" ref="ga5b0730a59b760cc42a5137e6c1b06c2cae3cd03231309fa38cb33e9d514409d97" args="" -->opdis_bit_flag_lsr</em>&nbsp;</td><td>
<p>Logical shift right </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ga5b0730a59b760cc42a5137e6c1b06c2cad4444ef8aa5096a594582c4b8f72e46c"></a><!-- doxytag: member="opdis_bit_flag_asl" ref="ga5b0730a59b760cc42a5137e6c1b06c2cad4444ef8aa5096a594582c4b8f72e46c" args="" -->opdis_bit_flag_asl</em>&nbsp;</td><td>
<p>Arithmetic shift left </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ga5b0730a59b760cc42a5137e6c1b06c2caf39eb321a9a92da4eb07db651ea09712"></a><!-- doxytag: member="opdis_bit_flag_asr" ref="ga5b0730a59b760cc42a5137e6c1b06c2caf39eb321a9a92da4eb07db651ea09712" args="" -->opdis_bit_flag_asr</em>&nbsp;</td><td>
<p>Arithmetic shift right </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ga5b0730a59b760cc42a5137e6c1b06c2caef3688fe4f61f7df610eb49f3d433960"></a><!-- doxytag: member="opdis_bit_flag_rol" ref="ga5b0730a59b760cc42a5137e6c1b06c2caef3688fe4f61f7df610eb49f3d433960" args="" -->opdis_bit_flag_rol</em>&nbsp;</td><td>
<p>Rotate left </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ga5b0730a59b760cc42a5137e6c1b06c2cabae0c89b17f47c00abe643331dbccda9"></a><!-- doxytag: member="opdis_bit_flag_ror" ref="ga5b0730a59b760cc42a5137e6c1b06c2cabae0c89b17f47c00abe643331dbccda9" args="" -->opdis_bit_flag_ror</em>&nbsp;</td><td>
<p>Rotate right </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ga5b0730a59b760cc42a5137e6c1b06c2cac2602381e6cd7a2a8a8a003f7e2454c1"></a><!-- doxytag: member="opdis_bit_flag_rcl" ref="ga5b0730a59b760cc42a5137e6c1b06c2cac2602381e6cd7a2a8a8a003f7e2454c1" args="" -->opdis_bit_flag_rcl</em>&nbsp;</td><td>
<p>Rotate left with carry </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ga5b0730a59b760cc42a5137e6c1b06c2ca9aff8e14e6f90b39fd00436408f4e348"></a><!-- doxytag: member="opdis_bit_flag_rcr" ref="ga5b0730a59b760cc42a5137e6c1b06c2ca9aff8e14e6f90b39fd00436408f4e348" args="" -->opdis_bit_flag_rcr</em>&nbsp;</td><td>
<p>Rotate right with carry </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="ga65b1d22eb012f92c4ea6cd4ec60a79c7"></a><!-- doxytag: member="metadata.h::opdis_cflow_flag_t" ref="ga65b1d22eb012f92c4ea6cd4ec60a79c7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__model.html#ga65b1d22eb012f92c4ea6cd4ec60a79c7">opdis_cflow_flag_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Details of the control flow instruction. </p>
<p>These flags encode specific information about the control flow instructions: is it a call, does it branch, is it a return, etc. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>It is the responsibility of the architecture-specific decoder to enure that the correct flags set. A missing flag does not necessarily mean that the flag does not apply, but may indicate that the decoder does not fully support the instruction. </dd></dl>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ga65b1d22eb012f92c4ea6cd4ec60a79c7a08f836c14da0102b00e7eb16ce177e2b"></a><!-- doxytag: member="opdis_cflow_flag_none" ref="ga65b1d22eb012f92c4ea6cd4ec60a79c7a08f836c14da0102b00e7eb16ce177e2b" args="" -->opdis_cflow_flag_none</em>&nbsp;</td><td>
<p>No flags </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ga65b1d22eb012f92c4ea6cd4ec60a79c7a7f6ce3512eeeb1f7ae31312093ec6d53"></a><!-- doxytag: member="opdis_cflow_flag_call" ref="ga65b1d22eb012f92c4ea6cd4ec60a79c7a7f6ce3512eeeb1f7ae31312093ec6d53" args="" -->opdis_cflow_flag_call</em>&nbsp;</td><td>
<p>Call </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ga65b1d22eb012f92c4ea6cd4ec60a79c7a04ac06c641a11f0f7b7eff51cbf30240"></a><!-- doxytag: member="opdis_cflow_flag_callcc" ref="ga65b1d22eb012f92c4ea6cd4ec60a79c7a04ac06c641a11f0f7b7eff51cbf30240" args="" -->opdis_cflow_flag_callcc</em>&nbsp;</td><td>
<p>Conditional call </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ga65b1d22eb012f92c4ea6cd4ec60a79c7ab7c7162b22ce85125c565256d3b02db1"></a><!-- doxytag: member="opdis_cflow_flag_jmp" ref="ga65b1d22eb012f92c4ea6cd4ec60a79c7ab7c7162b22ce85125c565256d3b02db1" args="" -->opdis_cflow_flag_jmp</em>&nbsp;</td><td>
<p>Jump </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ga65b1d22eb012f92c4ea6cd4ec60a79c7aee6601fc3faf9e82c9edf35ae04b2d7e"></a><!-- doxytag: member="opdis_cflow_flag_jmpcc" ref="ga65b1d22eb012f92c4ea6cd4ec60a79c7aee6601fc3faf9e82c9edf35ae04b2d7e" args="" -->opdis_cflow_flag_jmpcc</em>&nbsp;</td><td>
<p>Conditional jump </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ga65b1d22eb012f92c4ea6cd4ec60a79c7a79513228f151bb7ef3ec8683b139e501"></a><!-- doxytag: member="opdis_cflow_flag_ret" ref="ga65b1d22eb012f92c4ea6cd4ec60a79c7a79513228f151bb7ef3ec8683b139e501" args="" -->opdis_cflow_flag_ret</em>&nbsp;</td><td>
<p>Return from call </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="ga01216fda1b5bcd2337106b78d6fa3411"></a><!-- doxytag: member="metadata.h::opdis_insn_cat_t" ref="ga01216fda1b5bcd2337106b78d6fa3411" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__model.html#ga01216fda1b5bcd2337106b78d6fa3411">opdis_insn_cat_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The <em>category</em> of an instruction. </p>
<p>The type or <em>category</em> of an instruction. This is used to distinguish between instructions at a high level : control flow instructions (jmp, call, ret), stack instructions (push, pop), floating point instructions, etc. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>It is the responsibility of the architecture-specific decoder to enure that the correct category is set. A value of 'unknown' does not ensure that one of the other values is not suitable, but may indicate that the decoder does not fully support the instruction. </dd></dl>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ga01216fda1b5bcd2337106b78d6fa3411ae580691b2062852a47d94d5674cfb97c"></a><!-- doxytag: member="opdis_insn_cat_unknown" ref="ga01216fda1b5bcd2337106b78d6fa3411ae580691b2062852a47d94d5674cfb97c" args="" -->opdis_insn_cat_unknown</em>&nbsp;</td><td>
<p>Unknown instruction type </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ga01216fda1b5bcd2337106b78d6fa3411a8cdd463b0554f72c34f0293b200cc4a7"></a><!-- doxytag: member="opdis_insn_cat_cflow" ref="ga01216fda1b5bcd2337106b78d6fa3411a8cdd463b0554f72c34f0293b200cc4a7" args="" -->opdis_insn_cat_cflow</em>&nbsp;</td><td>
<p>Control flow instruction </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ga01216fda1b5bcd2337106b78d6fa3411a89cd76437838cd6c6370739e6a8f88c7"></a><!-- doxytag: member="opdis_insn_cat_stack" ref="ga01216fda1b5bcd2337106b78d6fa3411a89cd76437838cd6c6370739e6a8f88c7" args="" -->opdis_insn_cat_stack</em>&nbsp;</td><td>
<p>Stack manipulation instruction </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ga01216fda1b5bcd2337106b78d6fa3411a04a72773a6712bb419730f8b9a1ec28c"></a><!-- doxytag: member="opdis_insn_cat_lost" ref="ga01216fda1b5bcd2337106b78d6fa3411a04a72773a6712bb419730f8b9a1ec28c" args="" -->opdis_insn_cat_lost</em>&nbsp;</td><td>
<p>Load/store instruction </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ga01216fda1b5bcd2337106b78d6fa3411ad69608d8f0d7898810479d6632a4b1f9"></a><!-- doxytag: member="opdis_insn_cat_test" ref="ga01216fda1b5bcd2337106b78d6fa3411ad69608d8f0d7898810479d6632a4b1f9" args="" -->opdis_insn_cat_test</em>&nbsp;</td><td>
<p>Test/compare instruction </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ga01216fda1b5bcd2337106b78d6fa3411a128b9d9db646f487d7ae93c3c4256f1d"></a><!-- doxytag: member="opdis_insn_cat_math" ref="ga01216fda1b5bcd2337106b78d6fa3411a128b9d9db646f487d7ae93c3c4256f1d" args="" -->opdis_insn_cat_math</em>&nbsp;</td><td>
<p>Arithmetic instruction </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ga01216fda1b5bcd2337106b78d6fa3411a065e57e1e2659456ec83baa8297a6da1"></a><!-- doxytag: member="opdis_insn_cat_bit" ref="ga01216fda1b5bcd2337106b78d6fa3411a065e57e1e2659456ec83baa8297a6da1" args="" -->opdis_insn_cat_bit</em>&nbsp;</td><td>
<p>Bitwise (shift/and/or/etc) instruction </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ga01216fda1b5bcd2337106b78d6fa3411aadb2a5aa11013f45c5625a306bcfebb2"></a><!-- doxytag: member="opdis_insn_cat_io" ref="ga01216fda1b5bcd2337106b78d6fa3411aadb2a5aa11013f45c5625a306bcfebb2" args="" -->opdis_insn_cat_io</em>&nbsp;</td><td>
<p>I/O port instruction </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ga01216fda1b5bcd2337106b78d6fa3411a3e76b839ae62f089d82e8885e1845a40"></a><!-- doxytag: member="opdis_insn_cat_trap" ref="ga01216fda1b5bcd2337106b78d6fa3411a3e76b839ae62f089d82e8885e1845a40" args="" -->opdis_insn_cat_trap</em>&nbsp;</td><td>
<p>Interrupt/trap instruction </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ga01216fda1b5bcd2337106b78d6fa3411a65190c714821b66894646f47e797b7c7"></a><!-- doxytag: member="opdis_insn_cat_priv" ref="ga01216fda1b5bcd2337106b78d6fa3411a65190c714821b66894646f47e797b7c7" args="" -->opdis_insn_cat_priv</em>&nbsp;</td><td>
<p>Privileged (ring0) instruction </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ga01216fda1b5bcd2337106b78d6fa3411aa2a9066465c2f5b3efee21f5d66e24f0"></a><!-- doxytag: member="opdis_insn_cat_nop" ref="ga01216fda1b5bcd2337106b78d6fa3411aa2a9066465c2f5b3efee21f5d66e24f0" args="" -->opdis_insn_cat_nop</em>&nbsp;</td><td>
<p>No-operation instruction </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="gab3e66fe59b04d4eef45728bd9922d573"></a><!-- doxytag: member="metadata.h::opdis_insn_subset_t" ref="gab3e66fe59b04d4eef45728bd9922d573" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__model.html#gab3e66fe59b04d4eef45728bd9922d573">opdis_insn_subset_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The <em>subset</em> of an ISA that the instruction belongs to. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>It is the responsibility of the architecture-specific decoder to enure that the correct ISA is set. A value of 'general' does not ensure that one of the other values is not suitable, but may indicate that the decoder does not fully support the ISA. </dd></dl>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gab3e66fe59b04d4eef45728bd9922d573a3e655c97d6a45ab5952729eb740a7723"></a><!-- doxytag: member="opdis_insn_subset_gen" ref="gab3e66fe59b04d4eef45728bd9922d573a3e655c97d6a45ab5952729eb740a7723" args="" -->opdis_insn_subset_gen</em>&nbsp;</td><td>
<p>General-purpose instruction </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gab3e66fe59b04d4eef45728bd9922d573ac83c57ada475940d5af1ae0aacaba872"></a><!-- doxytag: member="opdis_insn_subset_fpu" ref="gab3e66fe59b04d4eef45728bd9922d573ac83c57ada475940d5af1ae0aacaba872" args="" -->opdis_insn_subset_fpu</em>&nbsp;</td><td>
<p>Floating-Point instruction </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gab3e66fe59b04d4eef45728bd9922d573ab9b6c105c6cdcc10e27d0d2fff178ecf"></a><!-- doxytag: member="opdis_insn_subset_gpu" ref="gab3e66fe59b04d4eef45728bd9922d573ab9b6c105c6cdcc10e27d0d2fff178ecf" args="" -->opdis_insn_subset_gpu</em>&nbsp;</td><td>
<p>GPU instruction </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gab3e66fe59b04d4eef45728bd9922d573a96900ff34ef8fb6480a0a934968fccb5"></a><!-- doxytag: member="opdis_insn_subset_simd" ref="gab3e66fe59b04d4eef45728bd9922d573a96900ff34ef8fb6480a0a934968fccb5" args="" -->opdis_insn_subset_simd</em>&nbsp;</td><td>
<p>SIMD extension instruction </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gab3e66fe59b04d4eef45728bd9922d573a0067ab941e35514f1ea1ab9e20a6e0b4"></a><!-- doxytag: member="opdis_insn_subset_vm" ref="gab3e66fe59b04d4eef45728bd9922d573a0067ab941e35514f1ea1ab9e20a6e0b4" args="" -->opdis_insn_subset_vm</em>&nbsp;</td><td>
<p>Virtual Machine extension </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="ga41baa012ac145f47d2b7d4be4b78bd49"></a><!-- doxytag: member="metadata.h::opdis_io_flag_t" ref="ga41baa012ac145f47d2b7d4be4b78bd49" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__model.html#ga41baa012ac145f47d2b7d4be4b78bd49">opdis_io_flag_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Details of the instruction. </p>
<p>These flags encode specific information about the instructions: does it read input from a port, does it write output to a port, etc. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>It is the responsibility of the architecture-specific decoder to enure that the correct flags set. A missing flag does not necessarily mean that the flag does not apply, but may indicate that the decoder does not fully support the instruction. </dd></dl>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ga41baa012ac145f47d2b7d4be4b78bd49a24dd27c0987cf4b53686a1aa12229286"></a><!-- doxytag: member="opdis_io_flag_none" ref="ga41baa012ac145f47d2b7d4be4b78bd49a24dd27c0987cf4b53686a1aa12229286" args="" -->opdis_io_flag_none</em>&nbsp;</td><td>
<p>No flags </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ga41baa012ac145f47d2b7d4be4b78bd49a7dad8577c5bbd8fc4c370dd41d16f0c7"></a><!-- doxytag: member="opdis_io_flag_in" ref="ga41baa012ac145f47d2b7d4be4b78bd49a7dad8577c5bbd8fc4c370dd41d16f0c7" args="" -->opdis_io_flag_in</em>&nbsp;</td><td>
<p>Input from port </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ga41baa012ac145f47d2b7d4be4b78bd49a4764e885449902b18ef0a8473a71f166"></a><!-- doxytag: member="opdis_io_flag_out" ref="ga41baa012ac145f47d2b7d4be4b78bd49a4764e885449902b18ef0a8473a71f166" args="" -->opdis_io_flag_out</em>&nbsp;</td><td>
<p>Output from port </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="ga28daebb5c77a83733a8a25d048770729"></a><!-- doxytag: member="metadata.h::opdis_op_cat_t" ref="ga28daebb5c77a83733a8a25d048770729" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__model.html#ga28daebb5c77a83733a8a25d048770729">opdis_op_cat_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The <em>category</em> of an operand. </p>
<p>The type or <em>category</em> of an instruction operand. This is used to distinguish between operands that are registers, memory locations, immediate values, or relative offsets. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>It is the responsibility of the architecture-specific decoder to enure that the correct category is set. A value of 'unknown' does not ensure that one of the other values is not suitable, but may indicate that the decoder does not fully support the operand. </dd></dl>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ga28daebb5c77a83733a8a25d048770729abe08409f1ffa17c2195073a760056e07"></a><!-- doxytag: member="opdis_op_cat_unknown" ref="ga28daebb5c77a83733a8a25d048770729abe08409f1ffa17c2195073a760056e07" args="" -->opdis_op_cat_unknown</em>&nbsp;</td><td>
<p>Unknown operand type </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ga28daebb5c77a83733a8a25d048770729a3fc3bf472fc34d332ba00d37b28edd51"></a><!-- doxytag: member="opdis_op_cat_register" ref="ga28daebb5c77a83733a8a25d048770729a3fc3bf472fc34d332ba00d37b28edd51" args="" -->opdis_op_cat_register</em>&nbsp;</td><td>
<p>CPU register </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ga28daebb5c77a83733a8a25d048770729acfc57cc8ba89fd85da6402774db986bc"></a><!-- doxytag: member="opdis_op_cat_immediate" ref="ga28daebb5c77a83733a8a25d048770729acfc57cc8ba89fd85da6402774db986bc" args="" -->opdis_op_cat_immediate</em>&nbsp;</td><td>
<p>Immediate value </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ga28daebb5c77a83733a8a25d048770729af6549aec4736930427d03a11d3ce85c1"></a><!-- doxytag: member="opdis_op_cat_absolute" ref="ga28daebb5c77a83733a8a25d048770729af6549aec4736930427d03a11d3ce85c1" args="" -->opdis_op_cat_absolute</em>&nbsp;</td><td>
<p>Absolute address (seg:offset) </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ga28daebb5c77a83733a8a25d048770729a42fbf2d9c2869245ccb9b09158ba706a"></a><!-- doxytag: member="opdis_op_cat_expr" ref="ga28daebb5c77a83733a8a25d048770729a42fbf2d9c2869245ccb9b09158ba706a" args="" -->opdis_op_cat_expr</em>&nbsp;</td><td>
<p>Address expression </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5ac390fb588453761de58abb3c0e268a"></a><!-- doxytag: member="metadata.h::opdis_op_flag_t" ref="ga5ac390fb588453761de58abb3c0e268a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__model.html#ga5ac390fb588453761de58abb3c0e268a">opdis_op_flag_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Flags applied to an operand. </p>
<p>Operand flags are used to encode additional information about the operand. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>It is the responsibility of the architecture-specific decoder to enure that the correct flags set. A missing flag does not necessarily mean that the flag does not apply, but may indicate that the decoder does not fully support the operand. </dd></dl>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ga5ac390fb588453761de58abb3c0e268aaa12e23871d56e8a981851c2e02c72568"></a><!-- doxytag: member="opdis_op_flag_none" ref="ga5ac390fb588453761de58abb3c0e268aaa12e23871d56e8a981851c2e02c72568" args="" -->opdis_op_flag_none</em>&nbsp;</td><td>
<p>No flags </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ga5ac390fb588453761de58abb3c0e268aae6e9457d9a989cff3f328321dfb06736"></a><!-- doxytag: member="opdis_op_flag_r" ref="ga5ac390fb588453761de58abb3c0e268aae6e9457d9a989cff3f328321dfb06736" args="" -->opdis_op_flag_r</em>&nbsp;</td><td>
<p>Operand is read by insn </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ga5ac390fb588453761de58abb3c0e268aac7d9cc4305acf9feea5adc62bef13ebe"></a><!-- doxytag: member="opdis_op_flag_w" ref="ga5ac390fb588453761de58abb3c0e268aac7d9cc4305acf9feea5adc62bef13ebe" args="" -->opdis_op_flag_w</em>&nbsp;</td><td>
<p>Operand is written by insn </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ga5ac390fb588453761de58abb3c0e268aa7d3130481f001b4160ab6858f0f6f1c2"></a><!-- doxytag: member="opdis_op_flag_x" ref="ga5ac390fb588453761de58abb3c0e268aa7d3130481f001b4160ab6858f0f6f1c2" args="" -->opdis_op_flag_x</em>&nbsp;</td><td>
<p>Operand is executed by insn </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ga5ac390fb588453761de58abb3c0e268aa5a8cf1e35309e2d12b51b3712bc0df69"></a><!-- doxytag: member="opdis_op_flag_signed" ref="ga5ac390fb588453761de58abb3c0e268aa5a8cf1e35309e2d12b51b3712bc0df69" args="" -->opdis_op_flag_signed</em>&nbsp;</td><td>
<p>Immediate data is signed </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ga5ac390fb588453761de58abb3c0e268aaace4ad9d894c9fb898191a516b2fdea7"></a><!-- doxytag: member="opdis_op_flag_address" ref="ga5ac390fb588453761de58abb3c0e268aaace4ad9d894c9fb898191a516b2fdea7" args="" -->opdis_op_flag_address</em>&nbsp;</td><td>
<p>Operand value is an address </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ga5ac390fb588453761de58abb3c0e268aa448e445b38869ae34df437d63fe67760"></a><!-- doxytag: member="opdis_op_flag_indirect" ref="ga5ac390fb588453761de58abb3c0e268aa448e445b38869ae34df437d63fe67760" args="" -->opdis_op_flag_indirect</em>&nbsp;</td><td>
<p>Operand value points to address </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="gaae467dfe6fa63d243f020741e7345762"></a><!-- doxytag: member="metadata.h::opdis_stack_flag_t" ref="gaae467dfe6fa63d243f020741e7345762" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__model.html#gaae467dfe6fa63d243f020741e7345762">opdis_stack_flag_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Details of the instruction. </p>
<p>These flags encode specific information about the instructions: is it a push or a pop, does it enter or leave a stack frame, etc. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>It is the responsibility of the architecture-specific decoder to enure that the correct flags set. A missing flag does not necessarily mean that the flag does not apply, but may indicate that the decoder does not fully support the instruction. </dd></dl>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gaae467dfe6fa63d243f020741e7345762a03c0ef0c06c56b2e6d5b1453afe515e4"></a><!-- doxytag: member="opdis_stack_flag_none" ref="gaae467dfe6fa63d243f020741e7345762a03c0ef0c06c56b2e6d5b1453afe515e4" args="" -->opdis_stack_flag_none</em>&nbsp;</td><td>
<p>No flags </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gaae467dfe6fa63d243f020741e7345762a55d2cfb01453e692d4561ebbd63f2e23"></a><!-- doxytag: member="opdis_stack_flag_push" ref="gaae467dfe6fa63d243f020741e7345762a55d2cfb01453e692d4561ebbd63f2e23" args="" -->opdis_stack_flag_push</em>&nbsp;</td><td>
<p>Push to stack </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gaae467dfe6fa63d243f020741e7345762a2e0515c8cb26af8c208a0d1968472e76"></a><!-- doxytag: member="opdis_stack_flag_pop" ref="gaae467dfe6fa63d243f020741e7345762a2e0515c8cb26af8c208a0d1968472e76" args="" -->opdis_stack_flag_pop</em>&nbsp;</td><td>
<p>Pop from stack </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gaae467dfe6fa63d243f020741e7345762ab1858bb31629a7ff17b8d1ac7d0e27a3"></a><!-- doxytag: member="opdis_stack_flag_frame" ref="gaae467dfe6fa63d243f020741e7345762ab1858bb31629a7ff17b8d1ac7d0e27a3" args="" -->opdis_stack_flag_frame</em>&nbsp;</td><td>
<p>Enter stack frame </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gaae467dfe6fa63d243f020741e7345762ab801f9904bec2d2e431b215e94e36476"></a><!-- doxytag: member="opdis_stack_flag_unframe" ref="gaae467dfe6fa63d243f020741e7345762ab801f9904bec2d2e431b215e94e36476" args="" -->opdis_stack_flag_unframe</em>&nbsp;</td><td>
<p>Exit stack frame </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga5b3db474b454e0b4f54fe05d7cc69930"></a><!-- doxytag: member="model.c::opdis_addr_expr_shift_str" ref="ga5b3db474b454e0b4f54fe05d7cc69930" args="(const opdis_addr_expr_t *exp, char *buf, int buf_len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int opdis_addr_expr_shift_str </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structopdis__addr__expr__t.html">opdis_addr_expr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>exp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>buf_len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generate a string representation of addr expression shift field. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>exp</em>&nbsp;</td><td>The address expression. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>The buffer to append the string to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buf_len</em>&nbsp;</td><td>The length of the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>If <em>buf</em> is not an empty string, it will be appended (not replaced). </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__model.html#gaff49a0e6824359e6212eac50853511e7" title="Generate a string representation of operand category field.">opdis_op_cat_str</a> </dd>
<dd>
<a class="el" href="group__model.html#ga6c8eb935b4778836b95cac7b39a41579" title="Generate a string representation of operand flags field.">opdis_op_flags_str</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga5f0a91fdadb0c8ba96431f120a3e7332"></a><!-- doxytag: member="model.c::opdis_insn_add_comment" ref="ga5f0a91fdadb0c8ba96431f120a3e7332" args="(opdis_insn_t *i, const char *cmt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opdis_insn_add_comment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopdis__insn__t.html">opdis_insn_t</a> *&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>cmt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Append a string to the <em>comment</em> field. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>i</em>&nbsp;</td><td>The instruction to modify. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cmt</em>&nbsp;</td><td>The value to append to the <em>comment</em> field. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5a1dfde629d11b74910b16c4d8bcefc1"></a><!-- doxytag: member="model.c::opdis_insn_add_operand" ref="ga5a1dfde629d11b74910b16c4d8bcefc1" args="(opdis_insn_t *i, opdis_op_t *op)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int opdis_insn_add_operand </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopdis__insn__t.html">opdis_insn_t</a> *&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopdis__op__t.html">opdis_op_t</a> *&nbsp;</td>
          <td class="paramname"> <em>op</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add an operand to an instruction. </p>
<p>Append an operand to the list of operands in the instruction. This does <em>not</em> duplicate the operand; it performs a realloc on the <em>operands</em> array, appends the pointer <em>op</em> to it, and increases the instruction count. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>i</em>&nbsp;</td><td>The instruction to modify. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>op</em>&nbsp;</td><td>The operand to append to the instruction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 on success, 0 on failure. </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>If the number of operands in <em>i</em> is less than the number of allocated operands in <em>i</em>, no realloc is performed. </dd></dl>

</div>
</div>
<a class="anchor" id="ga751521f2fb33dac1f6d3e8d7d68367cd"></a><!-- doxytag: member="model.c::opdis_insn_add_prefix" ref="ga751521f2fb33dac1f6d3e8d7d68367cd" args="(opdis_insn_t *i, const char *prefix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opdis_insn_add_prefix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopdis__insn__t.html">opdis_insn_t</a> *&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>prefix</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Append a string to the <em>prefix</em> field. </p>
<p>a a</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>i</em>&nbsp;</td><td>The instruction to modify. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>prefix</em>&nbsp;</td><td>The value to append to the <em>prefix</em> field. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4992e794ac0a88d4f80f9f1475e8f175"></a><!-- doxytag: member="model.c::opdis_insn_alloc" ref="ga4992e794ac0a88d4f80f9f1475e8f175" args="(opdis_off_t num_operands)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopdis__insn__t.html">opdis_insn_t</a> * opdis_insn_alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_8h.html#abd14f9464752cb16147541a663f70797">opdis_off_t</a>&nbsp;</td>
          <td class="paramname"> <em>num_operands</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate an instruction object and initialize its contents to zero. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>num_operands</em>&nbsp;</td><td>The number of operands to allocate, or 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The allocated instruction. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__model.html#gada22f42ccc5979fe1f93f90b4cd45f45" title="Free an allocated instruction object.">opdis_insn_free</a> </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The <em>ascii</em> and <em>mnemonic</em> fields are not allocated. </dd>
<dd>
The operands array is allocated as an empty array of pointers; the operands themselves are not allocated. </dd></dl>

</div>
</div>
<a class="anchor" id="gacd2254417c9ce98649d250504a3d9e5c"></a><!-- doxytag: member="model.c::opdis_insn_alloc_fixed" ref="gacd2254417c9ce98649d250504a3d9e5c" args="(size_t ascii_sz, size_t mnemonic_sz, size_t num_operands, size_t op_ascii_sz)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopdis__insn__t.html">opdis_insn_t</a> * opdis_insn_alloc_fixed </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>ascii_sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>mnemonic_sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>num_operands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>op_ascii_sz</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate a fixed-size instruction object for use as a buffer. </p>
<p>This allocates an instruction object with the specified number of operands, and with <em>ascii</em> and <em>mnemonic</em> allocated to the specified sizes. Each operand is allocated by opdis_op_alloc_fixed. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ascii_sz</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mnemonic_sz</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>num_operands</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>op_ascii_sz</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The allocated instruction. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__model.html#ga4992e794ac0a88d4f80f9f1475e8f175" title="Allocate an instruction object and initialize its contents to zero.">opdis_insn_alloc</a> </dd>
<dd>
<a class="el" href="group__model.html#gada22f42ccc5979fe1f93f90b4cd45f45" title="Free an allocated instruction object.">opdis_insn_free</a> </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The instruction object returned by this function is intended for use as a buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="gad5f349120a4b3813de59cbc03a158d1e"></a><!-- doxytag: member="model.c::opdis_insn_cat_str" ref="gad5f349120a4b3813de59cbc03a158d1e" args="(const opdis_insn_t *insn, char *buf, int buf_len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int opdis_insn_cat_str </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structopdis__insn__t.html">opdis_insn_t</a> *&nbsp;</td>
          <td class="paramname"> <em>insn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>buf_len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generate a string representation of instruction category field. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>i</em>&nbsp;</td><td>The instruction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>The buffer to append the string to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buf_len</em>&nbsp;</td><td>The length of the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>'/' should not be used as a delimiter, as some flags (e.g. load/store, i/o) use it in their string representation. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__model.html#ga371d9a1b5d5d7efc1f4d5fb5deeeafba" title="Generate a string representation of instruction isa field.">opdis_insn_isa_str</a> </dd>
<dd>
<a class="el" href="group__model.html#gaf686ee40be5c7c25f265f22c974c98f2" title="Generate a string representation of instruction flags field.">opdis_insn_flags_str</a> </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>If <em>buf</em> is not an empty string, it will be appended (not replaced). </dd></dl>

</div>
</div>
<a class="anchor" id="ga89a333b915634cb7f779bb113e385b93"></a><!-- doxytag: member="model.c::opdis_insn_clear" ref="ga89a333b915634cb7f779bb113e385b93" args="(opdis_insn_t *insn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opdis_insn_clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopdis__insn__t.html">opdis_insn_t</a> *&nbsp;</td>
          <td class="paramname"> <em>insn</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clear the contents of an instruction object. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>i</em>&nbsp;</td><td>The instruction to clear. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6c019dce7557b07130f039ffbbdfba0f"></a><!-- doxytag: member="model.c::opdis_insn_dupe" ref="ga6c019dce7557b07130f039ffbbdfba0f" args="(const opdis_insn_t *insn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopdis__insn__t.html">opdis_insn_t</a> * opdis_insn_dupe </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structopdis__insn__t.html">opdis_insn_t</a> *&nbsp;</td>
          <td class="paramname"> <em>insn</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Duplicate an instruction object. </p>
<p>Allocate an instruction object and initialize it with the contents of <em>i</em>. This is primarily used to create an instruction object from a fixed-size <a class="el" href="structopdis__insn__t.html" title="Instruction object.">opdis_insn_t</a>. The <em>ascii</em>, <em>mnemonic</em>, and <em>operands</em> fields are only as large as they need to be (i.e. the length of the string and the number of valid operands). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>i</em>&nbsp;</td><td>The instruction to duplicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The duplicate instruction. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__model.html#ga4992e794ac0a88d4f80f9f1475e8f175" title="Allocate an instruction object and initialize its contents to zero.">opdis_insn_alloc</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gae18f36b4e3e68e5448985d4a630252c8"></a><!-- doxytag: member="model.c::opdis_insn_fallthrough" ref="gae18f36b4e3e68e5448985d4a630252c8" args="(opdis_insn_t *i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int opdis_insn_fallthrough </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopdis__insn__t.html">opdis_insn_t</a> *&nbsp;</td>
          <td class="paramname"> <em>i</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determine if the execution falls through to the next instruction. </p>
<p>Returns true (1) if execution falls through to the subsequent instruction in memory. This is true for all instructions except unconditional jumps (JMP) and procedure returns (RET). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>i</em>&nbsp;</td><td>The instruction to examine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if execution continues, 0 otherwise. </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This will only work if of the decoder supports it. Check that status contains <em>opdis_decode_mnem_flags</em> before relying on the return value. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf686ee40be5c7c25f265f22c974c98f2"></a><!-- doxytag: member="model.c::opdis_insn_flags_str" ref="gaf686ee40be5c7c25f265f22c974c98f2" args="(const opdis_insn_t *insn, char *buf, int buf_len, const char *delim)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int opdis_insn_flags_str </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structopdis__insn__t.html">opdis_insn_t</a> *&nbsp;</td>
          <td class="paramname"> <em>insn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>buf_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>delim</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generate a string representation of instruction flags field. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>i</em>&nbsp;</td><td>The instruction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>The buffer to append the string to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buf_len</em>&nbsp;</td><td>The length of the buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>delim</em>&nbsp;</td><td>The delimiter to use between flags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__model.html#gad5f349120a4b3813de59cbc03a158d1e" title="Generate a string representation of instruction category field.">opdis_insn_cat_str</a> </dd>
<dd>
<a class="el" href="group__model.html#ga371d9a1b5d5d7efc1f4d5fb5deeeafba" title="Generate a string representation of instruction isa field.">opdis_insn_isa_str</a> </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>If <em>buf</em> is not an empty string, it will be appended (not replaced). </dd></dl>

</div>
</div>
<a class="anchor" id="gada22f42ccc5979fe1f93f90b4cd45f45"></a><!-- doxytag: member="model.c::opdis_insn_free" ref="gada22f42ccc5979fe1f93f90b4cd45f45" args="(opdis_insn_t *insn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opdis_insn_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopdis__insn__t.html">opdis_insn_t</a> *&nbsp;</td>
          <td class="paramname"> <em>insn</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Free an allocated instruction object. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>i</em>&nbsp;</td><td>The instruction to free. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__model.html#ga4992e794ac0a88d4f80f9f1475e8f175" title="Allocate an instruction object and initialize its contents to zero.">opdis_insn_alloc</a> </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This frees <em>ascii</em>, <em>mnemonic</em>, and all allocated operands. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0e3d911601d06794b5c9fc2b8087c2e8"></a><!-- doxytag: member="model.c::opdis_insn_is_branch" ref="ga0e3d911601d06794b5c9fc2b8087c2e8" args="(opdis_insn_t *i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int opdis_insn_is_branch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopdis__insn__t.html">opdis_insn_t</a> *&nbsp;</td>
          <td class="paramname"> <em>i</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determine if the instruction has a branch target operand. </p>
<p>Returns true (1) if the instruction has a branch target operand. The branch target operand is accessible via <em>i-&gt;target</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>i</em>&nbsp;</td><td>The instruction to examine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if the instruction has a branch target, 0 otherwise. </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This will only work if of the decoder supports it. Check that status contains both <em>opdis_decode_mnem_flags</em> and opdis_decode_ops before relying on the return value. </dd></dl>

</div>
</div>
<a class="anchor" id="ga371d9a1b5d5d7efc1f4d5fb5deeeafba"></a><!-- doxytag: member="model.c::opdis_insn_isa_str" ref="ga371d9a1b5d5d7efc1f4d5fb5deeeafba" args="(const opdis_insn_t *insn, char *buf, int buf_len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int opdis_insn_isa_str </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structopdis__insn__t.html">opdis_insn_t</a> *&nbsp;</td>
          <td class="paramname"> <em>insn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>buf_len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generate a string representation of instruction isa field. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>i</em>&nbsp;</td><td>The instruction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>The buffer to append the string to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buf_len</em>&nbsp;</td><td>The length of the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__model.html#gad5f349120a4b3813de59cbc03a158d1e" title="Generate a string representation of instruction category field.">opdis_insn_cat_str</a> </dd>
<dd>
<a class="el" href="group__model.html#gaf686ee40be5c7c25f265f22c974c98f2" title="Generate a string representation of instruction flags field.">opdis_insn_flags_str</a> </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>If <em>buf</em> is not an empty string, it will be appended (not replaced). </dd></dl>

</div>
</div>
<a class="anchor" id="ga075856ad59c43be9a86aec5ba5d992fd"></a><!-- doxytag: member="model.c::opdis_insn_next_avail_op" ref="ga075856ad59c43be9a86aec5ba5d992fd" args="(opdis_insn_t *i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopdis__op__t.html">opdis_op_t</a> * opdis_insn_next_avail_op </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopdis__insn__t.html">opdis_insn_t</a> *&nbsp;</td>
          <td class="paramname"> <em>i</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return next available allocated operand. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>i</em>&nbsp;</td><td>The instruction to containing the operand. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The next unused operand, or NULL if all allocated operands are used. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa6c2f53403d0b276d668a4ef4b87b8dd"></a><!-- doxytag: member="model.c::opdis_insn_set_ascii" ref="gaa6c2f53403d0b276d668a4ef4b87b8dd" args="(opdis_insn_t *i, const char *ascii)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opdis_insn_set_ascii </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopdis__insn__t.html">opdis_insn_t</a> *&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>ascii</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the <em>ascii</em> field of an instruction. </p>
<p>This duplicates the string <em>ascii</em> and sets the <em>ascii</em> field of <em>i</em> to the new string. If the <em>ascii</em> field is non-NULL, it is freed before the assignment. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>i</em>&nbsp;</td><td>The instruction to modify. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ascii</em>&nbsp;</td><td>The new value for the <em>ascii</em> field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__model.html#gad86b504bebfefd17efe68d602534c59a" title="Set the mnemonic field of an instruction.">opdis_insn_set_mnemonic</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gad86b504bebfefd17efe68d602534c59a"></a><!-- doxytag: member="model.c::opdis_insn_set_mnemonic" ref="gad86b504bebfefd17efe68d602534c59a" args="(opdis_insn_t *i, const char *mnemonic)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opdis_insn_set_mnemonic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopdis__insn__t.html">opdis_insn_t</a> *&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>mnemonic</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the <em>mnemonic</em> field of an instruction. </p>
<p>This duplicates the string <em>mnemonic</em> and sets the <em>mnemonic</em> field of <em>i</em> to the new string. If the <em>mnemonic</em> field is non-NULL, it is freed before the assignment. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>i</em>&nbsp;</td><td>The instruction to modify. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mnemonic</em>&nbsp;</td><td>The new value for the <em>mnemonic</em> field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__model.html#gaa6c2f53403d0b276d668a4ef4b87b8dd" title="Set the ascii field of an instruction.">opdis_insn_set_ascii</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaea56a07ea3b2720ef99c69e77b2dce39"></a><!-- doxytag: member="model.c::opdis_op_alloc" ref="gaea56a07ea3b2720ef99c69e77b2dce39" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopdis__op__t.html">opdis_op_t</a> * opdis_op_alloc </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate an operand object. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The allocated operand. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__model.html#ga24074cb8c02c91af679cf200f3c8f6a0" title="Free an allocated operand object.">opdis_op_free</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga215c544ed96df3ebf1617806049ab51f"></a><!-- doxytag: member="model.c::opdis_op_alloc_fixed" ref="ga215c544ed96df3ebf1617806049ab51f" args="(size_t ascii_sz)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopdis__op__t.html">opdis_op_t</a> * opdis_op_alloc_fixed </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>ascii_sz</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate a fixed-size operand object for use as a buffer. </p>
<p>This allocates an operand object with <em>ascii</em> allocated to the specified size. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ascii_sz</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The allocated operand. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__model.html#gaea56a07ea3b2720ef99c69e77b2dce39" title="Allocate an operand object.">opdis_op_alloc</a> </dd>
<dd>
<a class="el" href="group__model.html#ga24074cb8c02c91af679cf200f3c8f6a0" title="Free an allocated operand object.">opdis_op_free</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaff49a0e6824359e6212eac50853511e7"></a><!-- doxytag: member="model.c::opdis_op_cat_str" ref="gaff49a0e6824359e6212eac50853511e7" args="(const opdis_op_t *op, char *buf, int buf_len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int opdis_op_cat_str </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structopdis__op__t.html">opdis_op_t</a> *&nbsp;</td>
          <td class="paramname"> <em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>buf_len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generate a string representation of operand category field. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>op</em>&nbsp;</td><td>The operand. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>The buffer to append the string to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buf_len</em>&nbsp;</td><td>The length of the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>If <em>buf</em> is not an empty string, it will be appended (not replaced). </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__model.html#ga6c8eb935b4778836b95cac7b39a41579" title="Generate a string representation of operand flags field.">opdis_op_flags_str</a> </dd>
<dd>
<a class="el" href="group__model.html#gadba3bfc5784822f55c28fef293a454d3" title="Generate a string representation of register flags field.">opdis_reg_flags_str</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga8f58c4353bae9c990c6ce115bc7e1197"></a><!-- doxytag: member="model.c::opdis_op_clear" ref="ga8f58c4353bae9c990c6ce115bc7e1197" args="(opdis_op_t *op)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opdis_op_clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopdis__op__t.html">opdis_op_t</a> *&nbsp;</td>
          <td class="paramname"> <em>op</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clear the contents of an operand object. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>o</em>&nbsp;</td><td>The operand to clear. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga57fc4036087f36ac9a0db74573d03645"></a><!-- doxytag: member="model.c::opdis_op_dupe" ref="ga57fc4036087f36ac9a0db74573d03645" args="(opdis_op_t *op)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopdis__op__t.html">opdis_op_t</a> * opdis_op_dupe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopdis__op__t.html">opdis_op_t</a> *&nbsp;</td>
          <td class="paramname"> <em>op</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Duplicate an operand object. </p>
<p>Allocate an operand object and initialize it with the contents of <em>op</em>. This is primarily used to create an operand object from a fixed-size <a class="el" href="structopdis__op__t.html" title="Operand object.">opdis_op_t</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>op</em>&nbsp;</td><td>The operand to duplicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The duplicate operand. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__model.html#gaea56a07ea3b2720ef99c69e77b2dce39" title="Allocate an operand object.">opdis_op_alloc</a> </dd>
<dd>
<a class="el" href="group__model.html#ga6c019dce7557b07130f039ffbbdfba0f" title="Duplicate an instruction object.">opdis_insn_dupe</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga6c8eb935b4778836b95cac7b39a41579"></a><!-- doxytag: member="model.c::opdis_op_flags_str" ref="ga6c8eb935b4778836b95cac7b39a41579" args="(const opdis_op_t *op, char *buf, int buf_len, const char *delim)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int opdis_op_flags_str </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structopdis__op__t.html">opdis_op_t</a> *&nbsp;</td>
          <td class="paramname"> <em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>buf_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>delim</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generate a string representation of operand flags field. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>op</em>&nbsp;</td><td>The operand. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>The buffer to append the string to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buf_len</em>&nbsp;</td><td>The length of the buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>delim</em>&nbsp;</td><td>The delimiter to use between flags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>If <em>buf</em> is not an empty string, it will be appended (not replaced). </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__model.html#gaff49a0e6824359e6212eac50853511e7" title="Generate a string representation of operand category field.">opdis_op_cat_str</a> </dd>
<dd>
<a class="el" href="group__model.html#gadba3bfc5784822f55c28fef293a454d3" title="Generate a string representation of register flags field.">opdis_reg_flags_str</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga24074cb8c02c91af679cf200f3c8f6a0"></a><!-- doxytag: member="model.c::opdis_op_free" ref="ga24074cb8c02c91af679cf200f3c8f6a0" args="(opdis_op_t *op)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opdis_op_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopdis__op__t.html">opdis_op_t</a> *&nbsp;</td>
          <td class="paramname"> <em>op</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Free an allocated operand object. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>op</em>&nbsp;</td><td>The operand to free. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__model.html#gaea56a07ea3b2720ef99c69e77b2dce39" title="Allocate an operand object.">opdis_op_alloc</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gab02d492abf8059dbbd5083c4139e6712"></a><!-- doxytag: member="model.c::opdis_op_set_ascii" ref="gab02d492abf8059dbbd5083c4139e6712" args="(opdis_op_t *op, const char *ascii)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opdis_op_set_ascii </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopdis__op__t.html">opdis_op_t</a> *&nbsp;</td>
          <td class="paramname"> <em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>ascii</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the <em>ascii</em> field of an operand. </p>
<p>This duplicates the string <em>ascii</em> and sets the <em>ascii</em> field of <em>op</em> to the new string. If the <em>ascii</em> field is non-NULL, it is freed before the assignment. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>op</em>&nbsp;</td><td>The operand to modify </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ascii</em>&nbsp;</td><td>The new value for the <em>ascii</em> field. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gadba3bfc5784822f55c28fef293a454d3"></a><!-- doxytag: member="model.c::opdis_reg_flags_str" ref="gadba3bfc5784822f55c28fef293a454d3" args="(const opdis_reg_t *reg, char *buf, int buf_len, const char *delim)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int opdis_reg_flags_str </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structopdis__reg__t.html">opdis_reg_t</a> *&nbsp;</td>
          <td class="paramname"> <em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>buf_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>delim</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generate a string representation of register flags field. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>reg</em>&nbsp;</td><td>The register. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>The buffer to append the string to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buf_len</em>&nbsp;</td><td>The length of the buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>delim</em>&nbsp;</td><td>The delimiter to use between flags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>If <em>buf</em> is not an empty string, it will be appended (not replaced). </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__model.html#gaff49a0e6824359e6212eac50853511e7" title="Generate a string representation of operand category field.">opdis_op_cat_str</a> </dd>
<dd>
<a class="el" href="group__model.html#ga6c8eb935b4778836b95cac7b39a41579" title="Generate a string representation of operand flags field.">opdis_op_flags_str</a> </dd></dl>

</div>
</div>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Tue Mar 9 18:59:32 2010 for Opdis Disassembly Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
