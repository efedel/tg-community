<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Opdis Disassembly Library: Data Model</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Data Model</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopdis__reg__t.html">opdis_reg_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">CPU Register operand.  <a href="structopdis__reg__t.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopdis__abs__addr__t.html">opdis_abs_addr_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An absolute address operand.  <a href="structopdis__abs__addr__t.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopdis__addr__expr__t.html">opdis_addr_expr_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An address expression operand.  <a href="structopdis__addr__expr__t.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopdis__op__t.html">opdis_op_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Operand object.  <a href="structopdis__op__t.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopdis__insn__t.html">opdis_insn_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Instruction object.  <a href="structopdis__insn__t.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__model.html#ga28daebb5c77a83733a8a25d048770729">opdis_op_cat_t</a> { <br/>
&nbsp;&nbsp;<a class="el" href="group__model.html#ga28daebb5c77a83733a8a25d048770729abe08409f1ffa17c2195073a760056e07">opdis_op_cat_unknown</a>, 
<a class="el" href="group__model.html#ga28daebb5c77a83733a8a25d048770729a3fc3bf472fc34d332ba00d37b28edd51">opdis_op_cat_register</a>, 
<a class="el" href="group__model.html#ga28daebb5c77a83733a8a25d048770729acfc57cc8ba89fd85da6402774db986bc">opdis_op_cat_immediate</a>, 
<a class="el" href="group__model.html#ga28daebb5c77a83733a8a25d048770729af6549aec4736930427d03a11d3ce85c1">opdis_op_cat_absolute</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__model.html#ga28daebb5c77a83733a8a25d048770729a42fbf2d9c2869245ccb9b09158ba706a">opdis_op_cat_expr</a>
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>The <em>category</em> of an operand. </p>
 <a href="group__model.html#ga28daebb5c77a83733a8a25d048770729">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__model.html#ga5ac390fb588453761de58abb3c0e268a">opdis_op_flag_t</a> { <br/>
&nbsp;&nbsp;<a class="el" href="group__model.html#ga5ac390fb588453761de58abb3c0e268aaa12e23871d56e8a981851c2e02c72568">opdis_op_flag_none</a> =  0, 
<a class="el" href="group__model.html#ga5ac390fb588453761de58abb3c0e268aae6e9457d9a989cff3f328321dfb06736">opdis_op_flag_r</a> =  1, 
<a class="el" href="group__model.html#ga5ac390fb588453761de58abb3c0e268aac7d9cc4305acf9feea5adc62bef13ebe">opdis_op_flag_w</a> =  2, 
<a class="el" href="group__model.html#ga5ac390fb588453761de58abb3c0e268aa7d3130481f001b4160ab6858f0f6f1c2">opdis_op_flag_x</a> =  4, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__model.html#ga5ac390fb588453761de58abb3c0e268aa5a8cf1e35309e2d12b51b3712bc0df69">opdis_op_flag_signed</a> =  8, 
<a class="el" href="group__model.html#ga5ac390fb588453761de58abb3c0e268aaace4ad9d894c9fb898191a516b2fdea7">opdis_op_flag_address</a> =  16, 
<a class="el" href="group__model.html#ga5ac390fb588453761de58abb3c0e268aa448e445b38869ae34df437d63fe67760">opdis_op_flag_indirect</a> =  32
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Flags applied to an operand. </p>
 <a href="group__model.html#ga5ac390fb588453761de58abb3c0e268a">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__model.html#gab3e66fe59b04d4eef45728bd9922d573">opdis_insn_subset_t</a> { <br/>
&nbsp;&nbsp;<a class="el" href="group__model.html#gab3e66fe59b04d4eef45728bd9922d573a3e655c97d6a45ab5952729eb740a7723">opdis_insn_subset_gen</a>, 
<a class="el" href="group__model.html#gab3e66fe59b04d4eef45728bd9922d573ac83c57ada475940d5af1ae0aacaba872">opdis_insn_subset_fpu</a>, 
<a class="el" href="group__model.html#gab3e66fe59b04d4eef45728bd9922d573ab9b6c105c6cdcc10e27d0d2fff178ecf">opdis_insn_subset_gpu</a>, 
<a class="el" href="group__model.html#gab3e66fe59b04d4eef45728bd9922d573a96900ff34ef8fb6480a0a934968fccb5">opdis_insn_subset_simd</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__model.html#gab3e66fe59b04d4eef45728bd9922d573a0067ab941e35514f1ea1ab9e20a6e0b4">opdis_insn_subset_vm</a>
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>The <em>subset</em> of an ISA that the instruction belongs to. </p>
 <a href="group__model.html#gab3e66fe59b04d4eef45728bd9922d573">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__model.html#ga01216fda1b5bcd2337106b78d6fa3411">opdis_insn_cat_t</a> { <br/>
&nbsp;&nbsp;<a class="el" href="group__model.html#ga01216fda1b5bcd2337106b78d6fa3411ae580691b2062852a47d94d5674cfb97c">opdis_insn_cat_unknown</a>, 
<a class="el" href="group__model.html#ga01216fda1b5bcd2337106b78d6fa3411a8cdd463b0554f72c34f0293b200cc4a7">opdis_insn_cat_cflow</a>, 
<a class="el" href="group__model.html#ga01216fda1b5bcd2337106b78d6fa3411a89cd76437838cd6c6370739e6a8f88c7">opdis_insn_cat_stack</a>, 
<a class="el" href="group__model.html#ga01216fda1b5bcd2337106b78d6fa3411a04a72773a6712bb419730f8b9a1ec28c">opdis_insn_cat_lost</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__model.html#ga01216fda1b5bcd2337106b78d6fa3411ad69608d8f0d7898810479d6632a4b1f9">opdis_insn_cat_test</a>, 
<a class="el" href="group__model.html#ga01216fda1b5bcd2337106b78d6fa3411a128b9d9db646f487d7ae93c3c4256f1d">opdis_insn_cat_math</a>, 
<a class="el" href="group__model.html#ga01216fda1b5bcd2337106b78d6fa3411a065e57e1e2659456ec83baa8297a6da1">opdis_insn_cat_bit</a>, 
<a class="el" href="group__model.html#ga01216fda1b5bcd2337106b78d6fa3411aadb2a5aa11013f45c5625a306bcfebb2">opdis_insn_cat_io</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__model.html#ga01216fda1b5bcd2337106b78d6fa3411a3e76b839ae62f089d82e8885e1845a40">opdis_insn_cat_trap</a>, 
<a class="el" href="group__model.html#ga01216fda1b5bcd2337106b78d6fa3411a65190c714821b66894646f47e797b7c7">opdis_insn_cat_priv</a>, 
<a class="el" href="group__model.html#ga01216fda1b5bcd2337106b78d6fa3411aa2a9066465c2f5b3efee21f5d66e24f0">opdis_insn_cat_nop</a>
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>The <em>category</em> of an instruction. </p>
 <a href="group__model.html#ga01216fda1b5bcd2337106b78d6fa3411">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__model.html#ga65b1d22eb012f92c4ea6cd4ec60a79c7">opdis_cflow_flag_t</a> { <br/>
&nbsp;&nbsp;<a class="el" href="group__model.html#ga65b1d22eb012f92c4ea6cd4ec60a79c7a08f836c14da0102b00e7eb16ce177e2b">opdis_cflow_flag_none</a> = 0, 
<a class="el" href="group__model.html#ga65b1d22eb012f92c4ea6cd4ec60a79c7a7f6ce3512eeeb1f7ae31312093ec6d53">opdis_cflow_flag_call</a> = 1, 
<a class="el" href="group__model.html#ga65b1d22eb012f92c4ea6cd4ec60a79c7a04ac06c641a11f0f7b7eff51cbf30240">opdis_cflow_flag_callcc</a> = 2, 
<a class="el" href="group__model.html#ga65b1d22eb012f92c4ea6cd4ec60a79c7ab7c7162b22ce85125c565256d3b02db1">opdis_cflow_flag_jmp</a> = 4, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__model.html#ga65b1d22eb012f92c4ea6cd4ec60a79c7aee6601fc3faf9e82c9edf35ae04b2d7e">opdis_cflow_flag_jmpcc</a> = 8, 
<a class="el" href="group__model.html#ga65b1d22eb012f92c4ea6cd4ec60a79c7a79513228f151bb7ef3ec8683b139e501">opdis_cflow_flag_ret</a> = 16
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Details of the control flow instruction. </p>
 <a href="group__model.html#ga65b1d22eb012f92c4ea6cd4ec60a79c7">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__model.html#gaae467dfe6fa63d243f020741e7345762">opdis_stack_flag_t</a> { <br/>
&nbsp;&nbsp;<a class="el" href="group__model.html#gaae467dfe6fa63d243f020741e7345762a03c0ef0c06c56b2e6d5b1453afe515e4">opdis_stack_flag_none</a> = 0, 
<a class="el" href="group__model.html#gaae467dfe6fa63d243f020741e7345762a55d2cfb01453e692d4561ebbd63f2e23">opdis_stack_flag_push</a> = 1, 
<a class="el" href="group__model.html#gaae467dfe6fa63d243f020741e7345762a2e0515c8cb26af8c208a0d1968472e76">opdis_stack_flag_pop</a> = 2, 
<a class="el" href="group__model.html#gaae467dfe6fa63d243f020741e7345762ab1858bb31629a7ff17b8d1ac7d0e27a3">opdis_stack_flag_frame</a> = 4, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__model.html#gaae467dfe6fa63d243f020741e7345762ab801f9904bec2d2e431b215e94e36476">opdis_stack_flag_unframe</a> = 8
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Details of the instruction. </p>
 <a href="group__model.html#gaae467dfe6fa63d243f020741e7345762">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__model.html#ga5b0730a59b760cc42a5137e6c1b06c2c">opdis_bit_flag_t</a> { <br/>
&nbsp;&nbsp;<a class="el" href="group__model.html#ga5b0730a59b760cc42a5137e6c1b06c2ca9b7d976398cfef39744fe6f613120107">opdis_bit_flag_none</a> = 0, 
<a class="el" href="group__model.html#ga5b0730a59b760cc42a5137e6c1b06c2ca65627ec82b59b2849390bf364862e1a5">opdis_bit_flag_and</a> = 1, 
<a class="el" href="group__model.html#ga5b0730a59b760cc42a5137e6c1b06c2cad12f90ee70f587b082c97cd27a09c008">opdis_bit_flag_or</a> = 2, 
<a class="el" href="group__model.html#ga5b0730a59b760cc42a5137e6c1b06c2ca912c2bedc680cd184d96aaacb6a85bf6">opdis_bit_flag_xor</a> = 4, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__model.html#ga5b0730a59b760cc42a5137e6c1b06c2caf61342d45c8e8e0c925b0c7785f69dd7">opdis_bit_flag_not</a> = 8, 
<a class="el" href="group__model.html#ga5b0730a59b760cc42a5137e6c1b06c2ca904c4d381c31c9569b8b965cbdcba1fb">opdis_bit_flag_lsl</a> = 16, 
<a class="el" href="group__model.html#ga5b0730a59b760cc42a5137e6c1b06c2cae3cd03231309fa38cb33e9d514409d97">opdis_bit_flag_lsr</a> = 32, 
<a class="el" href="group__model.html#ga5b0730a59b760cc42a5137e6c1b06c2cad4444ef8aa5096a594582c4b8f72e46c">opdis_bit_flag_asl</a> = 64, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__model.html#ga5b0730a59b760cc42a5137e6c1b06c2caf39eb321a9a92da4eb07db651ea09712">opdis_bit_flag_asr</a> = 128, 
<a class="el" href="group__model.html#ga5b0730a59b760cc42a5137e6c1b06c2caef3688fe4f61f7df610eb49f3d433960">opdis_bit_flag_rol</a> = 256, 
<a class="el" href="group__model.html#ga5b0730a59b760cc42a5137e6c1b06c2cabae0c89b17f47c00abe643331dbccda9">opdis_bit_flag_ror</a> = 512, 
<a class="el" href="group__model.html#ga5b0730a59b760cc42a5137e6c1b06c2cac2602381e6cd7a2a8a8a003f7e2454c1">opdis_bit_flag_rcl</a> = 1024, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__model.html#ga5b0730a59b760cc42a5137e6c1b06c2ca9aff8e14e6f90b39fd00436408f4e348">opdis_bit_flag_rcr</a> = 2048
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Details of the instruction. </p>
 <a href="group__model.html#ga5b0730a59b760cc42a5137e6c1b06c2c">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__model.html#ga41baa012ac145f47d2b7d4be4b78bd49">opdis_io_flag_t</a> { <a class="el" href="group__model.html#ga41baa012ac145f47d2b7d4be4b78bd49a24dd27c0987cf4b53686a1aa12229286">opdis_io_flag_none</a> = 0, 
<a class="el" href="group__model.html#ga41baa012ac145f47d2b7d4be4b78bd49a7dad8577c5bbd8fc4c370dd41d16f0c7">opdis_io_flag_in</a> = 1, 
<a class="el" href="group__model.html#ga41baa012ac145f47d2b7d4be4b78bd49a4764e885449902b18ef0a8473a71f166">opdis_io_flag_out</a> = 2
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Details of the instruction. </p>
 <a href="group__model.html#ga41baa012ac145f47d2b7d4be4b78bd49">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__model.html#ga72a00cd036e505d7c7538fc4a4427549">opdis_addr_expr_elem_t</a> { <br/>
&nbsp;&nbsp;<a class="el" href="group__model.html#ga72a00cd036e505d7c7538fc4a4427549a7da50c024e16c54652bd2f69c7ac9f38">opdis_addr_expr_base</a> =  1, 
<a class="el" href="group__model.html#ga72a00cd036e505d7c7538fc4a4427549a5ac340b30bda9fd53320d59317bfec02">opdis_addr_expr_index</a> =  2, 
<a class="el" href="group__model.html#ga72a00cd036e505d7c7538fc4a4427549a945e4157c0d7217f1b31b024669bde78">opdis_addr_expr_disp</a> =  4, 
<a class="el" href="group__model.html#ga72a00cd036e505d7c7538fc4a4427549a89c104763523f580698ecacf44ab40b7">opdis_addr_expr_disp_u</a> =  8, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__model.html#ga72a00cd036e505d7c7538fc4a4427549ad55c8bf635d06c03cd3ad3f19f1be866">opdis_addr_expr_disp_s</a> =  16, 
<a class="el" href="group__model.html#ga72a00cd036e505d7c7538fc4a4427549a85ba48d151105995697c4d33495e357b">opdis_addr_expr_disp_abs</a> =  32
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Elements present in an address expression. </p>
 <a href="group__model.html#ga72a00cd036e505d7c7538fc4a4427549">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__model.html#gaeae037ecabe7c86e3abd9bd17eb2b0d5">opdis_addr_expr_shift_t</a> { <br/>
&nbsp;&nbsp;<a class="el" href="group__model.html#gaeae037ecabe7c86e3abd9bd17eb2b0d5aac06bf0fa37aaf0002dae24a7839a22d">opdis_addr_expr_lsl</a>, 
<a class="el" href="group__model.html#gaeae037ecabe7c86e3abd9bd17eb2b0d5a9128ed5498175b29c1bd9b53dcb251ad">opdis_addr_expr_lsr</a>, 
<a class="el" href="group__model.html#gaeae037ecabe7c86e3abd9bd17eb2b0d5a020bc1023e95ba05085e41bae8ad9cab">opdis_addr_expr_asl</a>, 
<a class="el" href="group__model.html#gaeae037ecabe7c86e3abd9bd17eb2b0d5a299405e00d612b2a9e30418cbff12a6a">opdis_addr_expr_ror</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__model.html#gaeae037ecabe7c86e3abd9bd17eb2b0d5a9a7a4d0ca41df501192c7a12d2da55e4">opdis_addr_expr_rrx</a>
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Type of shift operation used in address expression. </p>
 <a href="group__model.html#gaeae037ecabe7c86e3abd9bd17eb2b0d5">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structopdis__insn__t.html">opdis_insn_t</a> *LIBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__model.html#ga4992e794ac0a88d4f80f9f1475e8f175">opdis_insn_alloc</a> (<a class="el" href="types_8h.html#abd14f9464752cb16147541a663f70797">opdis_off_t</a> num_operands)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate an instruction object and initialize its contents to zero.  <a href="#ga4992e794ac0a88d4f80f9f1475e8f175"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structopdis__insn__t.html">opdis_insn_t</a> *LIBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__model.html#gacd2254417c9ce98649d250504a3d9e5c">opdis_insn_alloc_fixed</a> (size_t ascii_sz, size_t mnemonic_sz, size_t num_operands, size_t op_ascii_sz)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a fixed-size instruction object for use as a buffer.  <a href="#gacd2254417c9ce98649d250504a3d9e5c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structopdis__insn__t.html">opdis_insn_t</a> *LIBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__model.html#ga6c019dce7557b07130f039ffbbdfba0f">opdis_insn_dupe</a> (const <a class="el" href="structopdis__insn__t.html">opdis_insn_t</a> *insn)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Duplicate an instruction object.  <a href="#ga6c019dce7557b07130f039ffbbdfba0f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void LIBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__model.html#ga89a333b915634cb7f779bb113e385b93">opdis_insn_clear</a> (<a class="el" href="structopdis__insn__t.html">opdis_insn_t</a> *insn)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear the contents of an instruction object.  <a href="#ga89a333b915634cb7f779bb113e385b93"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void LIBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__model.html#gada22f42ccc5979fe1f93f90b4cd45f45">opdis_insn_free</a> (<a class="el" href="structopdis__insn__t.html">opdis_insn_t</a> *insn)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free an allocated instruction object.  <a href="#gada22f42ccc5979fe1f93f90b4cd45f45"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void LIBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__model.html#gaa6c2f53403d0b276d668a4ef4b87b8dd">opdis_insn_set_ascii</a> (<a class="el" href="structopdis__insn__t.html">opdis_insn_t</a> *i, const char *ascii)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the <em>ascii</em> field of an instruction.  <a href="#gaa6c2f53403d0b276d668a4ef4b87b8dd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void LIBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__model.html#gad86b504bebfefd17efe68d602534c59a">opdis_insn_set_mnemonic</a> (<a class="el" href="structopdis__insn__t.html">opdis_insn_t</a> *i, const char *mnemonic)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the <em>mnemonic</em> field of an instruction.  <a href="#gad86b504bebfefd17efe68d602534c59a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void LIBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__model.html#ga751521f2fb33dac1f6d3e8d7d68367cd">opdis_insn_add_prefix</a> (<a class="el" href="structopdis__insn__t.html">opdis_insn_t</a> *i, const char *prefix)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append a string to the <em>prefix</em> field.  <a href="#ga751521f2fb33dac1f6d3e8d7d68367cd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void LIBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__model.html#ga5f0a91fdadb0c8ba96431f120a3e7332">opdis_insn_add_comment</a> (<a class="el" href="structopdis__insn__t.html">opdis_insn_t</a> *i, const char *cmt)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append a string to the <em>comment</em> field.  <a href="#ga5f0a91fdadb0c8ba96431f120a3e7332"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int LIBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__model.html#ga5a1dfde629d11b74910b16c4d8bcefc1">opdis_insn_add_operand</a> (<a class="el" href="structopdis__insn__t.html">opdis_insn_t</a> *i, <a class="el" href="structopdis__op__t.html">opdis_op_t</a> *op)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add an operand to an instruction.  <a href="#ga5a1dfde629d11b74910b16c4d8bcefc1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structopdis__op__t.html">opdis_op_t</a> *LIBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__model.html#ga075856ad59c43be9a86aec5ba5d992fd">opdis_insn_next_avail_op</a> (<a class="el" href="structopdis__insn__t.html">opdis_insn_t</a> *i)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return next available allocated operand.  <a href="#ga075856ad59c43be9a86aec5ba5d992fd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int LIBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__model.html#ga0e3d911601d06794b5c9fc2b8087c2e8">opdis_insn_is_branch</a> (<a class="el" href="structopdis__insn__t.html">opdis_insn_t</a> *i)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine if the instruction has a branch target operand.  <a href="#ga0e3d911601d06794b5c9fc2b8087c2e8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int LIBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__model.html#gae18f36b4e3e68e5448985d4a630252c8">opdis_insn_fallthrough</a> (<a class="el" href="structopdis__insn__t.html">opdis_insn_t</a> *i)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine if the execution falls through to the next instruction.  <a href="#gae18f36b4e3e68e5448985d4a630252c8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int LIBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__model.html#ga371d9a1b5d5d7efc1f4d5fb5deeeafba">opdis_insn_isa_str</a> (const <a class="el" href="structopdis__insn__t.html">opdis_insn_t</a> *insn, char *buf, int buf_len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate a string representation of instruction isa field.  <a href="#ga371d9a1b5d5d7efc1f4d5fb5deeeafba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int LIBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__model.html#gad5f349120a4b3813de59cbc03a158d1e">opdis_insn_cat_str</a> (const <a class="el" href="structopdis__insn__t.html">opdis_insn_t</a> *insn, char *buf, int buf_len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate a string representation of instruction category field.  <a href="#gad5f349120a4b3813de59cbc03a158d1e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int LIBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__model.html#gaf686ee40be5c7c25f265f22c974c98f2">opdis_insn_flags_str</a> (const <a class="el" href="structopdis__insn__t.html">opdis_insn_t</a> *insn, char *buf, int buf_len, const char *delim)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate a string representation of instruction flags field.  <a href="#gaf686ee40be5c7c25f265f22c974c98f2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structopdis__op__t.html">opdis_op_t</a> *LIBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__model.html#gaea56a07ea3b2720ef99c69e77b2dce39">opdis_op_alloc</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate an operand object.  <a href="#gaea56a07ea3b2720ef99c69e77b2dce39"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structopdis__op__t.html">opdis_op_t</a> *LIBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__model.html#ga215c544ed96df3ebf1617806049ab51f">opdis_op_alloc_fixed</a> (size_t ascii_sz)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a fixed-size operand object for use as a buffer.  <a href="#ga215c544ed96df3ebf1617806049ab51f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structopdis__op__t.html">opdis_op_t</a> *LIBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__model.html#ga57fc4036087f36ac9a0db74573d03645">opdis_op_dupe</a> (<a class="el" href="structopdis__op__t.html">opdis_op_t</a> *op)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Duplicate an operand object.  <a href="#ga57fc4036087f36ac9a0db74573d03645"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void LIBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__model.html#ga8f58c4353bae9c990c6ce115bc7e1197">opdis_op_clear</a> (<a class="el" href="structopdis__op__t.html">opdis_op_t</a> *op)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear the contents of an operand object.  <a href="#ga8f58c4353bae9c990c6ce115bc7e1197"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void LIBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__model.html#ga24074cb8c02c91af679cf200f3c8f6a0">opdis_op_free</a> (<a class="el" href="structopdis__op__t.html">opdis_op_t</a> *op)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free an allocated operand object.  <a href="#ga24074cb8c02c91af679cf200f3c8f6a0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void LIBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__model.html#gab02d492abf8059dbbd5083c4139e6712">opdis_op_set_ascii</a> (<a class="el" href="structopdis__op__t.html">opdis_op_t</a> *op, const char *ascii)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the <em>ascii</em> field of an operand.  <a href="#gab02d492abf8059dbbd5083c4139e6712"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int LIBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__model.html#gaff49a0e6824359e6212eac50853511e7">opdis_op_cat_str</a> (const <a class="el" href="structopdis__op__t.html">opdis_op_t</a> *op, char *buf, int buf_len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate a string representation of operand category field.  <a href="#gaff49a0e6824359e6212eac50853511e7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int LIBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__model.html#ga6c8eb935b4778836b95cac7b39a41579">opdis_op_flags_str</a> (const <a class="el" href="structopdis__op__t.html">opdis_op_t</a> *op, char *buf, int buf_len, const char *delim)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate a string representation of operand flags field.  <a href="#ga6c8eb935b4778836b95cac7b39a41579"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int LIBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__model.html#gadba3bfc5784822f55c28fef293a454d3">opdis_reg_flags_str</a> (const <a class="el" href="structopdis__reg__t.html">opdis_reg_t</a> *reg, char *buf, int buf_len, const char *delim)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate a string representation of register flags field.  <a href="#gadba3bfc5784822f55c28fef293a454d3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int LIBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__model.html#ga5b3db474b454e0b4f54fe05d7cc69930">opdis_addr_expr_shift_str</a> (const <a class="el" href="structopdis__addr__expr__t.html">opdis_addr_expr_t</a> *exp, char *buf, int buf_len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate a string representation of addr expression shift field.  <a href="#ga5b3db474b454e0b4f54fe05d7cc69930"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Data Model for disassembled objects. </p>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="ga72a00cd036e505d7c7538fc4a4427549"></a><!-- doxytag: member="model.h::opdis_addr_expr_elem_t" ref="ga72a00cd036e505d7c7538fc4a4427549" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__model.html#ga72a00cd036e505d7c7538fc4a4427549">opdis_addr_expr_elem_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="structopdis__addr__expr__t.html" title="An address expression operand.">opdis_addr_expr_t</a> </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Scale factor is always present; it defaults to 1. </dd></dl>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ga72a00cd036e505d7c7538fc4a4427549a7da50c024e16c54652bd2f69c7ac9f38"></a><!-- doxytag: member="opdis_addr_expr_base" ref="ga72a00cd036e505d7c7538fc4a4427549a7da50c024e16c54652bd2f69c7ac9f38" args="" -->opdis_addr_expr_base</em>&nbsp;</td><td>
<p>Base register </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ga72a00cd036e505d7c7538fc4a4427549a5ac340b30bda9fd53320d59317bfec02"></a><!-- doxytag: member="opdis_addr_expr_index" ref="ga72a00cd036e505d7c7538fc4a4427549a5ac340b30bda9fd53320d59317bfec02" args="" -->opdis_addr_expr_index</em>&nbsp;</td><td>
<p>Index register </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ga72a00cd036e505d7c7538fc4a4427549a945e4157c0d7217f1b31b024669bde78"></a><!-- doxytag: member="opdis_addr_expr_disp" ref="ga72a00cd036e505d7c7538fc4a4427549a945e4157c0d7217f1b31b024669bde78" args="" -->opdis_addr_expr_disp</em>&nbsp;</td><td>
<p>Displacement </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ga72a00cd036e505d7c7538fc4a4427549a89c104763523f580698ecacf44ab40b7"></a><!-- doxytag: member="opdis_addr_expr_disp_u" ref="ga72a00cd036e505d7c7538fc4a4427549a89c104763523f580698ecacf44ab40b7" args="" -->opdis_addr_expr_disp_u</em>&nbsp;</td><td>
<p>Unsigned disp </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ga72a00cd036e505d7c7538fc4a4427549ad55c8bf635d06c03cd3ad3f19f1be866"></a><!-- doxytag: member="opdis_addr_expr_disp_s" ref="ga72a00cd036e505d7c7538fc4a4427549ad55c8bf635d06c03cd3ad3f19f1be866" args="" -->opdis_addr_expr_disp_s</em>&nbsp;</td><td>
<p>Signed disp </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ga72a00cd036e505d7c7538fc4a4427549a85ba48d151105995697c4d33495e357b"></a><!-- doxytag: member="opdis_addr_expr_disp_abs" ref="ga72a00cd036e505d7c7538fc4a4427549a85ba48d151105995697c4d33495e357b" args="" -->opdis_addr_expr_disp_abs</em>&nbsp;</td><td>
<p>Absolute addr disp </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="gaeae037ecabe7c86e3abd9bd17eb2b0d5"></a><!-- doxytag: member="model.h::opdis_addr_expr_shift_t" ref="gaeae037ecabe7c86e3abd9bd17eb2b0d5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__model.html#gaeae037ecabe7c86e3abd9bd17eb2b0d5">opdis_addr_expr_shift_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="structopdis__addr__expr__t.html" title="An address expression operand.">opdis_addr_expr_t</a> </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>These only apply to ARM; x86 is always ASL. </dd></dl>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gaeae037ecabe7c86e3abd9bd17eb2b0d5aac06bf0fa37aaf0002dae24a7839a22d"></a><!-- doxytag: member="opdis_addr_expr_lsl" ref="gaeae037ecabe7c86e3abd9bd17eb2b0d5aac06bf0fa37aaf0002dae24a7839a22d" args="" -->opdis_addr_expr_lsl</em>&nbsp;</td><td>
<p>Logical shift left </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gaeae037ecabe7c86e3abd9bd17eb2b0d5a9128ed5498175b29c1bd9b53dcb251ad"></a><!-- doxytag: member="opdis_addr_expr_lsr" ref="gaeae037ecabe7c86e3abd9bd17eb2b0d5a9128ed5498175b29c1bd9b53dcb251ad" args="" -->opdis_addr_expr_lsr</em>&nbsp;</td><td>
<p>Logical shift right </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gaeae037ecabe7c86e3abd9bd17eb2b0d5a020bc1023e95ba05085e41bae8ad9cab"></a><!-- doxytag: member="opdis_addr_expr_asl" ref="gaeae037ecabe7c86e3abd9bd17eb2b0d5a020bc1023e95ba05085e41bae8ad9cab" args="" -->opdis_addr_expr_asl</em>&nbsp;</td><td>
<p>Arithmetic shift left </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gaeae037ecabe7c86e3abd9bd17eb2b0d5a299405e00d612b2a9e30418cbff12a6a"></a><!-- doxytag: member="opdis_addr_expr_ror" ref="gaeae037ecabe7c86e3abd9bd17eb2b0d5a299405e00d612b2a9e30418cbff12a6a" args="" -->opdis_addr_expr_ror</em>&nbsp;</td><td>
<p>Rotate right </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gaeae037ecabe7c86e3abd9bd17eb2b0d5a9a7a4d0ca41df501192c7a12d2da55e4"></a><!-- doxytag: member="opdis_addr_expr_rrx" ref="gaeae037ecabe7c86e3abd9bd17eb2b0d5a9a7a4d0ca41df501192c7a12d2da55e4" args="" -->opdis_addr_expr_rrx</em>&nbsp;</td><td>
<p>Rotate right with carry </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5b0730a59b760cc42a5137e6c1b06c2c"></a><!-- doxytag: member="metadata.h::opdis_bit_flag_t" ref="ga5b0730a59b760cc42a5137e6c1b06c2c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__model.html#ga5b0730a59b760cc42a5137e6c1b06c2c">opdis_bit_flag_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>These flags encode specific information about the instructions: is it a shift or rotate (and is the carry flag significant), is it an AND/OR/XOR/NOT operation, etc. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>It is the responsibility of the architecture-specific decoder to enure that the correct flags set. A missing flag does not necessarily mean that the flag does not apply, but may indicate that the decoder does not fully support the instruction. </dd></dl>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ga5b0730a59b760cc42a5137e6c1b06c2ca9b7d976398cfef39744fe6f613120107"></a><!-- doxytag: member="opdis_bit_flag_none" ref="ga5b0730a59b760cc42a5137e6c1b06c2ca9b7d976398cfef39744fe6f613120107" args="" -->opdis_bit_flag_none</em>&nbsp;</td><td>
<p>No flags </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ga5b0730a59b760cc42a5137e6c1b06c2ca65627ec82b59b2849390bf364862e1a5"></a><!-- doxytag: member="opdis_bit_flag_and" ref="ga5b0730a59b760cc42a5137e6c1b06c2ca65627ec82b59b2849390bf364862e1a5" args="" -->opdis_bit_flag_and</em>&nbsp;</td><td>
<p>bitwise AND </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ga5b0730a59b760cc42a5137e6c1b06c2cad12f90ee70f587b082c97cd27a09c008"></a><!-- doxytag: member="opdis_bit_flag_or" ref="ga5b0730a59b760cc42a5137e6c1b06c2cad12f90ee70f587b082c97cd27a09c008" args="" -->opdis_bit_flag_or</em>&nbsp;</td><td>
<p>bitwise OR </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ga5b0730a59b760cc42a5137e6c1b06c2ca912c2bedc680cd184d96aaacb6a85bf6"></a><!-- doxytag: member="opdis_bit_flag_xor" ref="ga5b0730a59b760cc42a5137e6c1b06c2ca912c2bedc680cd184d96aaacb6a85bf6" args="" -->opdis_bit_flag_xor</em>&nbsp;</td><td>
<p>bitwise XOR </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ga5b0730a59b760cc42a5137e6c1b06c2caf61342d45c8e8e0c925b0c7785f69dd7"></a><!-- doxytag: member="opdis_bit_flag_not" ref="ga5b0730a59b760cc42a5137e6c1b06c2caf61342d45c8e8e0c925b0c7785f69dd7" args="" -->opdis_bit_flag_not</em>&nbsp;</td><td>
<p>bitwise NOT </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ga5b0730a59b760cc42a5137e6c1b06c2ca904c4d381c31c9569b8b965cbdcba1fb"></a><!-- doxytag: member="opdis_bit_flag_lsl" ref="ga5b0730a59b760cc42a5137e6c1b06c2ca904c4d381c31c9569b8b965cbdcba1fb" args="" -->opdis_bit_flag_lsl</em>&nbsp;</td><td>
<p>Logical shift left </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ga5b0730a59b760cc42a5137e6c1b06c2cae3cd03231309fa38cb33e9d514409d97"></a><!-- doxytag: member="opdis_bit_flag_lsr" ref="ga5b0730a59b760cc42a5137e6c1b06c2cae3cd03231309fa38cb33e9d514409d97" args="" -->opdis_bit_flag_lsr</em>&nbsp;</td><td>
<p>Logical shift right </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ga5b0730a59b760cc42a5137e6c1b06c2cad4444ef8aa5096a594582c4b8f72e46c"></a><!-- doxytag: member="opdis_bit_flag_asl" ref="ga5b0730a59b760cc42a5137e6c1b06c2cad4444ef8aa5096a594582c4b8f72e46c" args="" -->opdis_bit_flag_asl</em>&nbsp;</td><td>
<p>Arithmetic shift left </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ga5b0730a59b760cc42a5137e6c1b06c2caf39eb321a9a92da4eb07db651ea09712"></a><!-- doxytag: member="opdis_bit_flag_asr" ref="ga5b0730a59b760cc42a5137e6c1b06c2caf39eb321a9a92da4eb07db651ea09712" args="" -->opdis_bit_flag_asr</em>&nbsp;</td><td>
<p>Arithmetic shift right </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ga5b0730a59b760cc42a5137e6c1b06c2caef3688fe4f61f7df610eb49f3d433960"></a><!-- doxytag: member="opdis_bit_flag_rol" ref="ga5b0730a59b760cc42a5137e6c1b06c2caef3688fe4f61f7df610eb49f3d433960" args="" -->opdis_bit_flag_rol</em>&nbsp;</td><td>
<p>Rotate left </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ga5b0730a59b760cc42a5137e6c1b06c2cabae0c89b17f47c00abe643331dbccda9"></a><!-- doxytag: member="opdis_bit_flag_ror" ref="ga5b0730a59b760cc42a5137e6c1b06c2cabae0c89b17f47c00abe643331dbccda9" args="" -->opdis_bit_flag_ror</em>&nbsp;</td><td>
<p>Rotate right </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ga5b0730a59b760cc42a5137e6c1b06c2cac2602381e6cd7a2a8a8a003f7e2454c1"></a><!-- doxytag: member="opdis_bit_flag_rcl" ref="ga5b0730a59b760cc42a5137e6c1b06c2cac2602381e6cd7a2a8a8a003f7e2454c1" args="" -->opdis_bit_flag_rcl</em>&nbsp;</td><td>
<p>Rotate left with carry </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ga5b0730a59b760cc42a5137e6c1b06c2ca9aff8e14e6f90b39fd00436408f4e348"></a><!-- doxytag: member="opdis_bit_flag_rcr" ref="ga5b0730a59b760cc42a5137e6c1b06c2ca9aff8e14e6f90b39fd00436408f4e348" args="" -->opdis_bit_flag_rcr</em>&nbsp;</td><td>
<p>Rotate right with carry </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="ga65b1d22eb012f92c4ea6cd4ec60a79c7"></a><!-- doxytag: member="metadata.h::opdis_cflow_flag_t" ref="ga65b1d22eb012f92c4ea6cd4ec60a79c7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__model.html#ga65b1d22eb012f92c4ea6cd4ec60a79c7">opdis_cflow_flag_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>These flags encode specific information about the control flow instructions: is it a call, does it branch, is it a return, etc. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>It is the responsibility of the architecture-specific decoder to enure that the correct flags set. A missing flag does not necessarily mean that the flag does not apply, but may indicate that the decoder does not fully support the instruction. </dd></dl>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ga65b1d22eb012f92c4ea6cd4ec60a79c7a08f836c14da0102b00e7eb16ce177e2b"></a><!-- doxytag: member="opdis_cflow_flag_none" ref="ga65b1d22eb012f92c4ea6cd4ec60a79c7a08f836c14da0102b00e7eb16ce177e2b" args="" -->opdis_cflow_flag_none</em>&nbsp;</td><td>
<p>No flags </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ga65b1d22eb012f92c4ea6cd4ec60a79c7a7f6ce3512eeeb1f7ae31312093ec6d53"></a><!-- doxytag: member="opdis_cflow_flag_call" ref="ga65b1d22eb012f92c4ea6cd4ec60a79c7a7f6ce3512eeeb1f7ae31312093ec6d53" args="" -->opdis_cflow_flag_call</em>&nbsp;</td><td>
<p>Call </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ga65b1d22eb012f92c4ea6cd4ec60a79c7a04ac06c641a11f0f7b7eff51cbf30240"></a><!-- doxytag: member="opdis_cflow_flag_callcc" ref="ga65b1d22eb012f92c4ea6cd4ec60a79c7a04ac06c641a11f0f7b7eff51cbf30240" args="" -->opdis_cflow_flag_callcc</em>&nbsp;</td><td>
<p>Conditional call </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ga65b1d22eb012f92c4ea6cd4ec60a79c7ab7c7162b22ce85125c565256d3b02db1"></a><!-- doxytag: member="opdis_cflow_flag_jmp" ref="ga65b1d22eb012f92c4ea6cd4ec60a79c7ab7c7162b22ce85125c565256d3b02db1" args="" -->opdis_cflow_flag_jmp</em>&nbsp;</td><td>
<p>Jump </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ga65b1d22eb012f92c4ea6cd4ec60a79c7aee6601fc3faf9e82c9edf35ae04b2d7e"></a><!-- doxytag: member="opdis_cflow_flag_jmpcc" ref="ga65b1d22eb012f92c4ea6cd4ec60a79c7aee6601fc3faf9e82c9edf35ae04b2d7e" args="" -->opdis_cflow_flag_jmpcc</em>&nbsp;</td><td>
<p>Conditional jump </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ga65b1d22eb012f92c4ea6cd4ec60a79c7a79513228f151bb7ef3ec8683b139e501"></a><!-- doxytag: member="opdis_cflow_flag_ret" ref="ga65b1d22eb012f92c4ea6cd4ec60a79c7a79513228f151bb7ef3ec8683b139e501" args="" -->opdis_cflow_flag_ret</em>&nbsp;</td><td>
<p>Return from call </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="ga01216fda1b5bcd2337106b78d6fa3411"></a><!-- doxytag: member="metadata.h::opdis_insn_cat_t" ref="ga01216fda1b5bcd2337106b78d6fa3411" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__model.html#ga01216fda1b5bcd2337106b78d6fa3411">opdis_insn_cat_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The type or <em>category</em> of an instruction. This is used to distinguish between instructions at a high level : control flow instructions (jmp, call, ret), stack instructions (push, pop), floating point instructions, etc. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>It is the responsibility of the architecture-specific decoder to enure that the correct category is set. A value of 'unknown' does not ensure that one of the other values is not suitable, but may indicate that the decoder does not fully support the instruction. </dd></dl>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ga01216fda1b5bcd2337106b78d6fa3411ae580691b2062852a47d94d5674cfb97c"></a><!-- doxytag: member="opdis_insn_cat_unknown" ref="ga01216fda1b5bcd2337106b78d6fa3411ae580691b2062852a47d94d5674cfb97c" args="" -->opdis_insn_cat_unknown</em>&nbsp;</td><td>
<p>Unknown instruction type </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ga01216fda1b5bcd2337106b78d6fa3411a8cdd463b0554f72c34f0293b200cc4a7"></a><!-- doxytag: member="opdis_insn_cat_cflow" ref="ga01216fda1b5bcd2337106b78d6fa3411a8cdd463b0554f72c34f0293b200cc4a7" args="" -->opdis_insn_cat_cflow</em>&nbsp;</td><td>
<p>Control flow instruction </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ga01216fda1b5bcd2337106b78d6fa3411a89cd76437838cd6c6370739e6a8f88c7"></a><!-- doxytag: member="opdis_insn_cat_stack" ref="ga01216fda1b5bcd2337106b78d6fa3411a89cd76437838cd6c6370739e6a8f88c7" args="" -->opdis_insn_cat_stack</em>&nbsp;</td><td>
<p>Stack manipulation instruction </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ga01216fda1b5bcd2337106b78d6fa3411a04a72773a6712bb419730f8b9a1ec28c"></a><!-- doxytag: member="opdis_insn_cat_lost" ref="ga01216fda1b5bcd2337106b78d6fa3411a04a72773a6712bb419730f8b9a1ec28c" args="" -->opdis_insn_cat_lost</em>&nbsp;</td><td>
<p>Load/store instruction </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ga01216fda1b5bcd2337106b78d6fa3411ad69608d8f0d7898810479d6632a4b1f9"></a><!-- doxytag: member="opdis_insn_cat_test" ref="ga01216fda1b5bcd2337106b78d6fa3411ad69608d8f0d7898810479d6632a4b1f9" args="" -->opdis_insn_cat_test</em>&nbsp;</td><td>
<p>Test/compare instruction </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ga01216fda1b5bcd2337106b78d6fa3411a128b9d9db646f487d7ae93c3c4256f1d"></a><!-- doxytag: member="opdis_insn_cat_math" ref="ga01216fda1b5bcd2337106b78d6fa3411a128b9d9db646f487d7ae93c3c4256f1d" args="" -->opdis_insn_cat_math</em>&nbsp;</td><td>
<p>Arithmetic instruction </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ga01216fda1b5bcd2337106b78d6fa3411a065e57e1e2659456ec83baa8297a6da1"></a><!-- doxytag: member="opdis_insn_cat_bit" ref="ga01216fda1b5bcd2337106b78d6fa3411a065e57e1e2659456ec83baa8297a6da1" args="" -->opdis_insn_cat_bit</em>&nbsp;</td><td>
<p>Bitwise (shift/and/or/etc) instruction </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ga01216fda1b5bcd2337106b78d6fa3411aadb2a5aa11013f45c5625a306bcfebb2"></a><!-- doxytag: member="opdis_insn_cat_io" ref="ga01216fda1b5bcd2337106b78d6fa3411aadb2a5aa11013f45c5625a306bcfebb2" args="" -->opdis_insn_cat_io</em>&nbsp;</td><td>
<p>I/O port instruction </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ga01216fda1b5bcd2337106b78d6fa3411a3e76b839ae62f089d82e8885e1845a40"></a><!-- doxytag: member="opdis_insn_cat_trap" ref="ga01216fda1b5bcd2337106b78d6fa3411a3e76b839ae62f089d82e8885e1845a40" args="" -->opdis_insn_cat_trap</em>&nbsp;</td><td>
<p>Interrupt/trap instruction </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ga01216fda1b5bcd2337106b78d6fa3411a65190c714821b66894646f47e797b7c7"></a><!-- doxytag: member="opdis_insn_cat_priv" ref="ga01216fda1b5bcd2337106b78d6fa3411a65190c714821b66894646f47e797b7c7" args="" -->opdis_insn_cat_priv</em>&nbsp;</td><td>
<p>Privileged (ring0) instruction </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ga01216fda1b5bcd2337106b78d6fa3411aa2a9066465c2f5b3efee21f5d66e24f0"></a><!-- doxytag: member="opdis_insn_cat_nop" ref="ga01216fda1b5bcd2337106b78d6fa3411aa2a9066465c2f5b3efee21f5d66e24f0" args="" -->opdis_insn_cat_nop</em>&nbsp;</td><td>
<p>No-operation instruction </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="gab3e66fe59b04d4eef45728bd9922d573"></a><!-- doxytag: member="metadata.h::opdis_insn_subset_t" ref="gab3e66fe59b04d4eef45728bd9922d573" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__model.html#gab3e66fe59b04d4eef45728bd9922d573">opdis_insn_subset_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="note"><dt><b>Note:</b></dt><dd>It is the responsibility of the architecture-specific decoder to enure that the correct ISA is set. A value of 'general' does not ensure that one of the other values is not suitable, but may indicate that the decoder does not fully support the ISA. </dd></dl>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gab3e66fe59b04d4eef45728bd9922d573a3e655c97d6a45ab5952729eb740a7723"></a><!-- doxytag: member="opdis_insn_subset_gen" ref="gab3e66fe59b04d4eef45728bd9922d573a3e655c97d6a45ab5952729eb740a7723" args="" -->opdis_insn_subset_gen</em>&nbsp;</td><td>
<p>General-purpose instruction </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gab3e66fe59b04d4eef45728bd9922d573ac83c57ada475940d5af1ae0aacaba872"></a><!-- doxytag: member="opdis_insn_subset_fpu" ref="gab3e66fe59b04d4eef45728bd9922d573ac83c57ada475940d5af1ae0aacaba872" args="" -->opdis_insn_subset_fpu</em>&nbsp;</td><td>
<p>Floating-Point instruction </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gab3e66fe59b04d4eef45728bd9922d573ab9b6c105c6cdcc10e27d0d2fff178ecf"></a><!-- doxytag: member="opdis_insn_subset_gpu" ref="gab3e66fe59b04d4eef45728bd9922d573ab9b6c105c6cdcc10e27d0d2fff178ecf" args="" -->opdis_insn_subset_gpu</em>&nbsp;</td><td>
<p>GPU instruction </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gab3e66fe59b04d4eef45728bd9922d573a96900ff34ef8fb6480a0a934968fccb5"></a><!-- doxytag: member="opdis_insn_subset_simd" ref="gab3e66fe59b04d4eef45728bd9922d573a96900ff34ef8fb6480a0a934968fccb5" args="" -->opdis_insn_subset_simd</em>&nbsp;</td><td>
<p>SIMD extension instruction </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gab3e66fe59b04d4eef45728bd9922d573a0067ab941e35514f1ea1ab9e20a6e0b4"></a><!-- doxytag: member="opdis_insn_subset_vm" ref="gab3e66fe59b04d4eef45728bd9922d573a0067ab941e35514f1ea1ab9e20a6e0b4" args="" -->opdis_insn_subset_vm</em>&nbsp;</td><td>
<p>Virtual Machine extension </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="ga41baa012ac145f47d2b7d4be4b78bd49"></a><!-- doxytag: member="metadata.h::opdis_io_flag_t" ref="ga41baa012ac145f47d2b7d4be4b78bd49" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__model.html#ga41baa012ac145f47d2b7d4be4b78bd49">opdis_io_flag_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>These flags encode specific information about the instructions: does it read input from a port, does it write output to a port, etc. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>It is the responsibility of the architecture-specific decoder to enure that the correct flags set. A missing flag does not necessarily mean that the flag does not apply, but may indicate that the decoder does not fully support the instruction. </dd></dl>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ga41baa012ac145f47d2b7d4be4b78bd49a24dd27c0987cf4b53686a1aa12229286"></a><!-- doxytag: member="opdis_io_flag_none" ref="ga41baa012ac145f47d2b7d4be4b78bd49a24dd27c0987cf4b53686a1aa12229286" args="" -->opdis_io_flag_none</em>&nbsp;</td><td>
<p>No flags </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ga41baa012ac145f47d2b7d4be4b78bd49a7dad8577c5bbd8fc4c370dd41d16f0c7"></a><!-- doxytag: member="opdis_io_flag_in" ref="ga41baa012ac145f47d2b7d4be4b78bd49a7dad8577c5bbd8fc4c370dd41d16f0c7" args="" -->opdis_io_flag_in</em>&nbsp;</td><td>
<p>Input from port </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ga41baa012ac145f47d2b7d4be4b78bd49a4764e885449902b18ef0a8473a71f166"></a><!-- doxytag: member="opdis_io_flag_out" ref="ga41baa012ac145f47d2b7d4be4b78bd49a4764e885449902b18ef0a8473a71f166" args="" -->opdis_io_flag_out</em>&nbsp;</td><td>
<p>Output from port </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="ga28daebb5c77a83733a8a25d048770729"></a><!-- doxytag: member="metadata.h::opdis_op_cat_t" ref="ga28daebb5c77a83733a8a25d048770729" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__model.html#ga28daebb5c77a83733a8a25d048770729">opdis_op_cat_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The type or <em>category</em> of an instruction operand. This is used to distinguish between operands that are registers, memory locations, immediate values, or relative offsets. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>It is the responsibility of the architecture-specific decoder to enure that the correct category is set. A value of 'unknown' does not ensure that one of the other values is not suitable, but may indicate that the decoder does not fully support the operand. </dd></dl>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ga28daebb5c77a83733a8a25d048770729abe08409f1ffa17c2195073a760056e07"></a><!-- doxytag: member="opdis_op_cat_unknown" ref="ga28daebb5c77a83733a8a25d048770729abe08409f1ffa17c2195073a760056e07" args="" -->opdis_op_cat_unknown</em>&nbsp;</td><td>
<p>Unknown operand type </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ga28daebb5c77a83733a8a25d048770729a3fc3bf472fc34d332ba00d37b28edd51"></a><!-- doxytag: member="opdis_op_cat_register" ref="ga28daebb5c77a83733a8a25d048770729a3fc3bf472fc34d332ba00d37b28edd51" args="" -->opdis_op_cat_register</em>&nbsp;</td><td>
<p>CPU register </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ga28daebb5c77a83733a8a25d048770729acfc57cc8ba89fd85da6402774db986bc"></a><!-- doxytag: member="opdis_op_cat_immediate" ref="ga28daebb5c77a83733a8a25d048770729acfc57cc8ba89fd85da6402774db986bc" args="" -->opdis_op_cat_immediate</em>&nbsp;</td><td>
<p>Immediate value </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ga28daebb5c77a83733a8a25d048770729af6549aec4736930427d03a11d3ce85c1"></a><!-- doxytag: member="opdis_op_cat_absolute" ref="ga28daebb5c77a83733a8a25d048770729af6549aec4736930427d03a11d3ce85c1" args="" -->opdis_op_cat_absolute</em>&nbsp;</td><td>
<p>Absolute address (seg:offset) </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ga28daebb5c77a83733a8a25d048770729a42fbf2d9c2869245ccb9b09158ba706a"></a><!-- doxytag: member="opdis_op_cat_expr" ref="ga28daebb5c77a83733a8a25d048770729a42fbf2d9c2869245ccb9b09158ba706a" args="" -->opdis_op_cat_expr</em>&nbsp;</td><td>
<p>Address expression </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5ac390fb588453761de58abb3c0e268a"></a><!-- doxytag: member="metadata.h::opdis_op_flag_t" ref="ga5ac390fb588453761de58abb3c0e268a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__model.html#ga5ac390fb588453761de58abb3c0e268a">opdis_op_flag_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Operand flags are used to encode additional information about the operand. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>It is the responsibility of the architecture-specific decoder to enure that the correct flags set. A missing flag does not necessarily mean that the flag does not apply, but may indicate that the decoder does not fully support the operand. </dd></dl>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ga5ac390fb588453761de58abb3c0e268aaa12e23871d56e8a981851c2e02c72568"></a><!-- doxytag: member="opdis_op_flag_none" ref="ga5ac390fb588453761de58abb3c0e268aaa12e23871d56e8a981851c2e02c72568" args="" -->opdis_op_flag_none</em>&nbsp;</td><td>
<p>No flags </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ga5ac390fb588453761de58abb3c0e268aae6e9457d9a989cff3f328321dfb06736"></a><!-- doxytag: member="opdis_op_flag_r" ref="ga5ac390fb588453761de58abb3c0e268aae6e9457d9a989cff3f328321dfb06736" args="" -->opdis_op_flag_r</em>&nbsp;</td><td>
<p>Operand is read by insn </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ga5ac390fb588453761de58abb3c0e268aac7d9cc4305acf9feea5adc62bef13ebe"></a><!-- doxytag: member="opdis_op_flag_w" ref="ga5ac390fb588453761de58abb3c0e268aac7d9cc4305acf9feea5adc62bef13ebe" args="" -->opdis_op_flag_w</em>&nbsp;</td><td>
<p>Operand is written by insn </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ga5ac390fb588453761de58abb3c0e268aa7d3130481f001b4160ab6858f0f6f1c2"></a><!-- doxytag: member="opdis_op_flag_x" ref="ga5ac390fb588453761de58abb3c0e268aa7d3130481f001b4160ab6858f0f6f1c2" args="" -->opdis_op_flag_x</em>&nbsp;</td><td>
<p>Operand is executed by insn </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ga5ac390fb588453761de58abb3c0e268aa5a8cf1e35309e2d12b51b3712bc0df69"></a><!-- doxytag: member="opdis_op_flag_signed" ref="ga5ac390fb588453761de58abb3c0e268aa5a8cf1e35309e2d12b51b3712bc0df69" args="" -->opdis_op_flag_signed</em>&nbsp;</td><td>
<p>Immediate data is signed </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ga5ac390fb588453761de58abb3c0e268aaace4ad9d894c9fb898191a516b2fdea7"></a><!-- doxytag: member="opdis_op_flag_address" ref="ga5ac390fb588453761de58abb3c0e268aaace4ad9d894c9fb898191a516b2fdea7" args="" -->opdis_op_flag_address</em>&nbsp;</td><td>
<p>Operand value is an address </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ga5ac390fb588453761de58abb3c0e268aa448e445b38869ae34df437d63fe67760"></a><!-- doxytag: member="opdis_op_flag_indirect" ref="ga5ac390fb588453761de58abb3c0e268aa448e445b38869ae34df437d63fe67760" args="" -->opdis_op_flag_indirect</em>&nbsp;</td><td>
<p>Operand value points to address </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="gaae467dfe6fa63d243f020741e7345762"></a><!-- doxytag: member="metadata.h::opdis_stack_flag_t" ref="gaae467dfe6fa63d243f020741e7345762" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__model.html#gaae467dfe6fa63d243f020741e7345762">opdis_stack_flag_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>These flags encode specific information about the instructions: is it a push or a pop, does it enter or leave a stack frame, etc. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>It is the responsibility of the architecture-specific decoder to enure that the correct flags set. A missing flag does not necessarily mean that the flag does not apply, but may indicate that the decoder does not fully support the instruction. </dd></dl>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gaae467dfe6fa63d243f020741e7345762a03c0ef0c06c56b2e6d5b1453afe515e4"></a><!-- doxytag: member="opdis_stack_flag_none" ref="gaae467dfe6fa63d243f020741e7345762a03c0ef0c06c56b2e6d5b1453afe515e4" args="" -->opdis_stack_flag_none</em>&nbsp;</td><td>
<p>No flags </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gaae467dfe6fa63d243f020741e7345762a55d2cfb01453e692d4561ebbd63f2e23"></a><!-- doxytag: member="opdis_stack_flag_push" ref="gaae467dfe6fa63d243f020741e7345762a55d2cfb01453e692d4561ebbd63f2e23" args="" -->opdis_stack_flag_push</em>&nbsp;</td><td>
<p>Push to stack </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gaae467dfe6fa63d243f020741e7345762a2e0515c8cb26af8c208a0d1968472e76"></a><!-- doxytag: member="opdis_stack_flag_pop" ref="gaae467dfe6fa63d243f020741e7345762a2e0515c8cb26af8c208a0d1968472e76" args="" -->opdis_stack_flag_pop</em>&nbsp;</td><td>
<p>Pop from stack </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gaae467dfe6fa63d243f020741e7345762ab1858bb31629a7ff17b8d1ac7d0e27a3"></a><!-- doxytag: member="opdis_stack_flag_frame" ref="gaae467dfe6fa63d243f020741e7345762ab1858bb31629a7ff17b8d1ac7d0e27a3" args="" -->opdis_stack_flag_frame</em>&nbsp;</td><td>
<p>Enter stack frame </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gaae467dfe6fa63d243f020741e7345762ab801f9904bec2d2e431b215e94e36476"></a><!-- doxytag: member="opdis_stack_flag_unframe" ref="gaae467dfe6fa63d243f020741e7345762ab801f9904bec2d2e431b215e94e36476" args="" -->opdis_stack_flag_unframe</em>&nbsp;</td><td>
<p>Exit stack frame </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga5b3db474b454e0b4f54fe05d7cc69930"></a><!-- doxytag: member="model.c::opdis_addr_expr_shift_str" ref="ga5b3db474b454e0b4f54fe05d7cc69930" args="(const opdis_addr_expr_t *exp, char *buf, int buf_len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int opdis_addr_expr_shift_str </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structopdis__addr__expr__t.html">opdis_addr_expr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>exp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>buf_len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>exp</em>&nbsp;</td><td>The address expression. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>The buffer to append the string to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buf_len</em>&nbsp;</td><td>The length of the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>If <em>buf</em> is not an empty string, it will be appended (not replaced). </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__model.html#gaff49a0e6824359e6212eac50853511e7" title="Generate a string representation of operand category field.">opdis_op_cat_str</a> </dd>
<dd>
<a class="el" href="group__model.html#ga6c8eb935b4778836b95cac7b39a41579" title="Generate a string representation of operand flags field.">opdis_op_flags_str</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga5f0a91fdadb0c8ba96431f120a3e7332"></a><!-- doxytag: member="model.c::opdis_insn_add_comment" ref="ga5f0a91fdadb0c8ba96431f120a3e7332" args="(opdis_insn_t *i, const char *cmt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opdis_insn_add_comment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopdis__insn__t.html">opdis_insn_t</a> *&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>cmt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>i</em>&nbsp;</td><td>The instruction to modify. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cmt</em>&nbsp;</td><td>The value to append to the <em>comment</em> field. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5a1dfde629d11b74910b16c4d8bcefc1"></a><!-- doxytag: member="model.c::opdis_insn_add_operand" ref="ga5a1dfde629d11b74910b16c4d8bcefc1" args="(opdis_insn_t *i, opdis_op_t *op)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int opdis_insn_add_operand </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopdis__insn__t.html">opdis_insn_t</a> *&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopdis__op__t.html">opdis_op_t</a> *&nbsp;</td>
          <td class="paramname"> <em>op</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Append an operand to the list of operands in the instruction. This does <em>not</em> duplicate the operand; it performs a realloc on the <em>operands</em> array, appends the pointer <em>op</em> to it, and increases the instruction count. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>i</em>&nbsp;</td><td>The instruction to modify. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>op</em>&nbsp;</td><td>The operand to append to the instruction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 on success, 0 on failure. </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>If the number of operands in <em>i</em> is less than the number of allocated operands in <em>i</em>, no realloc is performed. </dd></dl>

</div>
</div>
<a class="anchor" id="ga751521f2fb33dac1f6d3e8d7d68367cd"></a><!-- doxytag: member="model.c::opdis_insn_add_prefix" ref="ga751521f2fb33dac1f6d3e8d7d68367cd" args="(opdis_insn_t *i, const char *prefix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opdis_insn_add_prefix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopdis__insn__t.html">opdis_insn_t</a> *&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>prefix</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>a a</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>i</em>&nbsp;</td><td>The instruction to modify. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>prefix</em>&nbsp;</td><td>The value to append to the <em>prefix</em> field. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4992e794ac0a88d4f80f9f1475e8f175"></a><!-- doxytag: member="model.c::opdis_insn_alloc" ref="ga4992e794ac0a88d4f80f9f1475e8f175" args="(opdis_off_t num_operands)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopdis__insn__t.html">opdis_insn_t</a> * opdis_insn_alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_8h.html#abd14f9464752cb16147541a663f70797">opdis_off_t</a>&nbsp;</td>
          <td class="paramname"> <em>num_operands</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>num_operands</em>&nbsp;</td><td>The number of operands to allocate, or 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The allocated instruction. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__model.html#gada22f42ccc5979fe1f93f90b4cd45f45" title="Free an allocated instruction object.">opdis_insn_free</a> </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The <em>ascii</em> and <em>mnemonic</em> fields are not allocated. </dd>
<dd>
The operands array is allocated as an empty array of pointers; the operands themselves are not allocated. </dd></dl>

</div>
</div>
<a class="anchor" id="gacd2254417c9ce98649d250504a3d9e5c"></a><!-- doxytag: member="model.c::opdis_insn_alloc_fixed" ref="gacd2254417c9ce98649d250504a3d9e5c" args="(size_t ascii_sz, size_t mnemonic_sz, size_t num_operands, size_t op_ascii_sz)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopdis__insn__t.html">opdis_insn_t</a> * opdis_insn_alloc_fixed </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>ascii_sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>mnemonic_sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>num_operands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>op_ascii_sz</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This allocates an instruction object with the specified number of operands, and with <em>ascii</em> and <em>mnemonic</em> allocated to the specified sizes. Each operand is allocated by opdis_op_alloc_fixed. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ascii_sz</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mnemonic_sz</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>num_operands</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>op_ascii_sz</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The allocated instruction. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__model.html#ga4992e794ac0a88d4f80f9f1475e8f175" title="Allocate an instruction object and initialize its contents to zero.">opdis_insn_alloc</a> </dd>
<dd>
<a class="el" href="group__model.html#gada22f42ccc5979fe1f93f90b4cd45f45" title="Free an allocated instruction object.">opdis_insn_free</a> </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The instruction object returned by this function is intended for use as a buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="gad5f349120a4b3813de59cbc03a158d1e"></a><!-- doxytag: member="model.c::opdis_insn_cat_str" ref="gad5f349120a4b3813de59cbc03a158d1e" args="(const opdis_insn_t *insn, char *buf, int buf_len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int opdis_insn_cat_str </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structopdis__insn__t.html">opdis_insn_t</a> *&nbsp;</td>
          <td class="paramname"> <em>insn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>buf_len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>i</em>&nbsp;</td><td>The instruction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>The buffer to append the string to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buf_len</em>&nbsp;</td><td>The length of the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>'/' should not be used as a delimiter, as some flags (e.g. load/store, i/o) use it in their string representation. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__model.html#ga371d9a1b5d5d7efc1f4d5fb5deeeafba" title="Generate a string representation of instruction isa field.">opdis_insn_isa_str</a> </dd>
<dd>
<a class="el" href="group__model.html#gaf686ee40be5c7c25f265f22c974c98f2" title="Generate a string representation of instruction flags field.">opdis_insn_flags_str</a> </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>If <em>buf</em> is not an empty string, it will be appended (not replaced). </dd></dl>

</div>
</div>
<a class="anchor" id="ga89a333b915634cb7f779bb113e385b93"></a><!-- doxytag: member="model.c::opdis_insn_clear" ref="ga89a333b915634cb7f779bb113e385b93" args="(opdis_insn_t *insn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opdis_insn_clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopdis__insn__t.html">opdis_insn_t</a> *&nbsp;</td>
          <td class="paramname"> <em>insn</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>i</em>&nbsp;</td><td>The instruction to clear. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6c019dce7557b07130f039ffbbdfba0f"></a><!-- doxytag: member="model.c::opdis_insn_dupe" ref="ga6c019dce7557b07130f039ffbbdfba0f" args="(const opdis_insn_t *insn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopdis__insn__t.html">opdis_insn_t</a> * opdis_insn_dupe </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structopdis__insn__t.html">opdis_insn_t</a> *&nbsp;</td>
          <td class="paramname"> <em>insn</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Allocate an instruction object and initialize it with the contents of <em>i</em>. This is primarily used to create an instruction object from a fixed-size <a class="el" href="structopdis__insn__t.html" title="Instruction object.">opdis_insn_t</a>. The <em>ascii</em>, <em>mnemonic</em>, and <em>operands</em> fields are only as large as they need to be (i.e. the length of the string and the number of valid operands). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>i</em>&nbsp;</td><td>The instruction to duplicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The duplicate instruction. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__model.html#ga4992e794ac0a88d4f80f9f1475e8f175" title="Allocate an instruction object and initialize its contents to zero.">opdis_insn_alloc</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gae18f36b4e3e68e5448985d4a630252c8"></a><!-- doxytag: member="model.c::opdis_insn_fallthrough" ref="gae18f36b4e3e68e5448985d4a630252c8" args="(opdis_insn_t *i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int opdis_insn_fallthrough </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopdis__insn__t.html">opdis_insn_t</a> *&nbsp;</td>
          <td class="paramname"> <em>i</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true (1) if execution falls through to the subsequent instruction in memory. This is true for all instructions except unconditional jumps (JMP) and procedure returns (RET). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>i</em>&nbsp;</td><td>The instruction to examine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if execution continues, 0 otherwise. </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This will only work if of the decoder supports it. Check that status contains <em>opdis_decode_mnem_flags</em> before relying on the return value. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf686ee40be5c7c25f265f22c974c98f2"></a><!-- doxytag: member="model.c::opdis_insn_flags_str" ref="gaf686ee40be5c7c25f265f22c974c98f2" args="(const opdis_insn_t *insn, char *buf, int buf_len, const char *delim)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int opdis_insn_flags_str </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structopdis__insn__t.html">opdis_insn_t</a> *&nbsp;</td>
          <td class="paramname"> <em>insn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>buf_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>delim</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>i</em>&nbsp;</td><td>The instruction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>The buffer to append the string to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buf_len</em>&nbsp;</td><td>The length of the buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>delim</em>&nbsp;</td><td>The delimiter to use between flags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__model.html#gad5f349120a4b3813de59cbc03a158d1e" title="Generate a string representation of instruction category field.">opdis_insn_cat_str</a> </dd>
<dd>
<a class="el" href="group__model.html#ga371d9a1b5d5d7efc1f4d5fb5deeeafba" title="Generate a string representation of instruction isa field.">opdis_insn_isa_str</a> </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>If <em>buf</em> is not an empty string, it will be appended (not replaced). </dd></dl>

</div>
</div>
<a class="anchor" id="gada22f42ccc5979fe1f93f90b4cd45f45"></a><!-- doxytag: member="model.c::opdis_insn_free" ref="gada22f42ccc5979fe1f93f90b4cd45f45" args="(opdis_insn_t *insn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opdis_insn_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopdis__insn__t.html">opdis_insn_t</a> *&nbsp;</td>
          <td class="paramname"> <em>insn</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>i</em>&nbsp;</td><td>The instruction to free. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__model.html#ga4992e794ac0a88d4f80f9f1475e8f175" title="Allocate an instruction object and initialize its contents to zero.">opdis_insn_alloc</a> </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This frees <em>ascii</em>, <em>mnemonic</em>, and all allocated operands. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0e3d911601d06794b5c9fc2b8087c2e8"></a><!-- doxytag: member="model.c::opdis_insn_is_branch" ref="ga0e3d911601d06794b5c9fc2b8087c2e8" args="(opdis_insn_t *i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int opdis_insn_is_branch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopdis__insn__t.html">opdis_insn_t</a> *&nbsp;</td>
          <td class="paramname"> <em>i</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true (1) if the instruction has a branch target operand. The branch target operand is accessible via <em>i-&gt;target</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>i</em>&nbsp;</td><td>The instruction to examine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if the instruction has a branch target, 0 otherwise. </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This will only work if of the decoder supports it. Check that status contains both <em>opdis_decode_mnem_flags</em> and opdis_decode_ops before relying on the return value. </dd></dl>

</div>
</div>
<a class="anchor" id="ga371d9a1b5d5d7efc1f4d5fb5deeeafba"></a><!-- doxytag: member="model.c::opdis_insn_isa_str" ref="ga371d9a1b5d5d7efc1f4d5fb5deeeafba" args="(const opdis_insn_t *insn, char *buf, int buf_len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int opdis_insn_isa_str </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structopdis__insn__t.html">opdis_insn_t</a> *&nbsp;</td>
          <td class="paramname"> <em>insn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>buf_len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>i</em>&nbsp;</td><td>The instruction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>The buffer to append the string to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buf_len</em>&nbsp;</td><td>The length of the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__model.html#gad5f349120a4b3813de59cbc03a158d1e" title="Generate a string representation of instruction category field.">opdis_insn_cat_str</a> </dd>
<dd>
<a class="el" href="group__model.html#gaf686ee40be5c7c25f265f22c974c98f2" title="Generate a string representation of instruction flags field.">opdis_insn_flags_str</a> </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>If <em>buf</em> is not an empty string, it will be appended (not replaced). </dd></dl>

</div>
</div>
<a class="anchor" id="ga075856ad59c43be9a86aec5ba5d992fd"></a><!-- doxytag: member="model.c::opdis_insn_next_avail_op" ref="ga075856ad59c43be9a86aec5ba5d992fd" args="(opdis_insn_t *i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopdis__op__t.html">opdis_op_t</a> * opdis_insn_next_avail_op </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopdis__insn__t.html">opdis_insn_t</a> *&nbsp;</td>
          <td class="paramname"> <em>i</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>i</em>&nbsp;</td><td>The instruction to containing the operand. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The next unused operand, or NULL if all allocated operands are used. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa6c2f53403d0b276d668a4ef4b87b8dd"></a><!-- doxytag: member="model.c::opdis_insn_set_ascii" ref="gaa6c2f53403d0b276d668a4ef4b87b8dd" args="(opdis_insn_t *i, const char *ascii)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opdis_insn_set_ascii </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopdis__insn__t.html">opdis_insn_t</a> *&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>ascii</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This duplicates the string <em>ascii</em> and sets the <em>ascii</em> field of <em>i</em> to the new string. If the <em>ascii</em> field is non-NULL, it is freed before the assignment. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>i</em>&nbsp;</td><td>The instruction to modify. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ascii</em>&nbsp;</td><td>The new value for the <em>ascii</em> field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__model.html#gad86b504bebfefd17efe68d602534c59a" title="Set the mnemonic field of an instruction.">opdis_insn_set_mnemonic</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gad86b504bebfefd17efe68d602534c59a"></a><!-- doxytag: member="model.c::opdis_insn_set_mnemonic" ref="gad86b504bebfefd17efe68d602534c59a" args="(opdis_insn_t *i, const char *mnemonic)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opdis_insn_set_mnemonic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopdis__insn__t.html">opdis_insn_t</a> *&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>mnemonic</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This duplicates the string <em>mnemonic</em> and sets the <em>mnemonic</em> field of <em>i</em> to the new string. If the <em>mnemonic</em> field is non-NULL, it is freed before the assignment. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>i</em>&nbsp;</td><td>The instruction to modify. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mnemonic</em>&nbsp;</td><td>The new value for the <em>mnemonic</em> field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__model.html#gaa6c2f53403d0b276d668a4ef4b87b8dd" title="Set the ascii field of an instruction.">opdis_insn_set_ascii</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaea56a07ea3b2720ef99c69e77b2dce39"></a><!-- doxytag: member="model.c::opdis_op_alloc" ref="gaea56a07ea3b2720ef99c69e77b2dce39" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopdis__op__t.html">opdis_op_t</a> * opdis_op_alloc </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>The allocated operand. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__model.html#ga24074cb8c02c91af679cf200f3c8f6a0" title="Free an allocated operand object.">opdis_op_free</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga215c544ed96df3ebf1617806049ab51f"></a><!-- doxytag: member="model.c::opdis_op_alloc_fixed" ref="ga215c544ed96df3ebf1617806049ab51f" args="(size_t ascii_sz)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopdis__op__t.html">opdis_op_t</a> * opdis_op_alloc_fixed </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>ascii_sz</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This allocates an operand object with <em>ascii</em> allocated to the specified size. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ascii_sz</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The allocated operand. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__model.html#gaea56a07ea3b2720ef99c69e77b2dce39" title="Allocate an operand object.">opdis_op_alloc</a> </dd>
<dd>
<a class="el" href="group__model.html#ga24074cb8c02c91af679cf200f3c8f6a0" title="Free an allocated operand object.">opdis_op_free</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaff49a0e6824359e6212eac50853511e7"></a><!-- doxytag: member="model.c::opdis_op_cat_str" ref="gaff49a0e6824359e6212eac50853511e7" args="(const opdis_op_t *op, char *buf, int buf_len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int opdis_op_cat_str </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structopdis__op__t.html">opdis_op_t</a> *&nbsp;</td>
          <td class="paramname"> <em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>buf_len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>op</em>&nbsp;</td><td>The operand. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>The buffer to append the string to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buf_len</em>&nbsp;</td><td>The length of the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>If <em>buf</em> is not an empty string, it will be appended (not replaced). </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__model.html#ga6c8eb935b4778836b95cac7b39a41579" title="Generate a string representation of operand flags field.">opdis_op_flags_str</a> </dd>
<dd>
<a class="el" href="group__model.html#gadba3bfc5784822f55c28fef293a454d3" title="Generate a string representation of register flags field.">opdis_reg_flags_str</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga8f58c4353bae9c990c6ce115bc7e1197"></a><!-- doxytag: member="model.c::opdis_op_clear" ref="ga8f58c4353bae9c990c6ce115bc7e1197" args="(opdis_op_t *op)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opdis_op_clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopdis__op__t.html">opdis_op_t</a> *&nbsp;</td>
          <td class="paramname"> <em>op</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>o</em>&nbsp;</td><td>The operand to clear. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga57fc4036087f36ac9a0db74573d03645"></a><!-- doxytag: member="model.c::opdis_op_dupe" ref="ga57fc4036087f36ac9a0db74573d03645" args="(opdis_op_t *op)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopdis__op__t.html">opdis_op_t</a> * opdis_op_dupe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopdis__op__t.html">opdis_op_t</a> *&nbsp;</td>
          <td class="paramname"> <em>op</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Allocate an operand object and initialize it with the contents of <em>op</em>. This is primarily used to create an operand object from a fixed-size <a class="el" href="structopdis__op__t.html" title="Operand object.">opdis_op_t</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>op</em>&nbsp;</td><td>The operand to duplicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The duplicate operand. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__model.html#gaea56a07ea3b2720ef99c69e77b2dce39" title="Allocate an operand object.">opdis_op_alloc</a> </dd>
<dd>
<a class="el" href="group__model.html#ga6c019dce7557b07130f039ffbbdfba0f" title="Duplicate an instruction object.">opdis_insn_dupe</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga6c8eb935b4778836b95cac7b39a41579"></a><!-- doxytag: member="model.c::opdis_op_flags_str" ref="ga6c8eb935b4778836b95cac7b39a41579" args="(const opdis_op_t *op, char *buf, int buf_len, const char *delim)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int opdis_op_flags_str </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structopdis__op__t.html">opdis_op_t</a> *&nbsp;</td>
          <td class="paramname"> <em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>buf_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>delim</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>op</em>&nbsp;</td><td>The operand. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>The buffer to append the string to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buf_len</em>&nbsp;</td><td>The length of the buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>delim</em>&nbsp;</td><td>The delimiter to use between flags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>If <em>buf</em> is not an empty string, it will be appended (not replaced). </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__model.html#gaff49a0e6824359e6212eac50853511e7" title="Generate a string representation of operand category field.">opdis_op_cat_str</a> </dd>
<dd>
<a class="el" href="group__model.html#gadba3bfc5784822f55c28fef293a454d3" title="Generate a string representation of register flags field.">opdis_reg_flags_str</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga24074cb8c02c91af679cf200f3c8f6a0"></a><!-- doxytag: member="model.c::opdis_op_free" ref="ga24074cb8c02c91af679cf200f3c8f6a0" args="(opdis_op_t *op)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opdis_op_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopdis__op__t.html">opdis_op_t</a> *&nbsp;</td>
          <td class="paramname"> <em>op</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>op</em>&nbsp;</td><td>The operand to free. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__model.html#gaea56a07ea3b2720ef99c69e77b2dce39" title="Allocate an operand object.">opdis_op_alloc</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gab02d492abf8059dbbd5083c4139e6712"></a><!-- doxytag: member="model.c::opdis_op_set_ascii" ref="gab02d492abf8059dbbd5083c4139e6712" args="(opdis_op_t *op, const char *ascii)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opdis_op_set_ascii </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopdis__op__t.html">opdis_op_t</a> *&nbsp;</td>
          <td class="paramname"> <em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>ascii</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This duplicates the string <em>ascii</em> and sets the <em>ascii</em> field of <em>op</em> to the new string. If the <em>ascii</em> field is non-NULL, it is freed before the assignment. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>op</em>&nbsp;</td><td>The operand to modify </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ascii</em>&nbsp;</td><td>The new value for the <em>ascii</em> field. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gadba3bfc5784822f55c28fef293a454d3"></a><!-- doxytag: member="model.c::opdis_reg_flags_str" ref="gadba3bfc5784822f55c28fef293a454d3" args="(const opdis_reg_t *reg, char *buf, int buf_len, const char *delim)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int opdis_reg_flags_str </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structopdis__reg__t.html">opdis_reg_t</a> *&nbsp;</td>
          <td class="paramname"> <em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>buf_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>delim</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>reg</em>&nbsp;</td><td>The register. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>The buffer to append the string to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buf_len</em>&nbsp;</td><td>The length of the buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>delim</em>&nbsp;</td><td>The delimiter to use between flags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>If <em>buf</em> is not an empty string, it will be appended (not replaced). </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__model.html#gaff49a0e6824359e6212eac50853511e7" title="Generate a string representation of operand category field.">opdis_op_cat_str</a> </dd>
<dd>
<a class="el" href="group__model.html#ga6c8eb935b4778836b95cac7b39a41579" title="Generate a string representation of operand flags field.">opdis_op_flags_str</a> </dd></dl>

</div>
</div>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Sat Mar 6 18:51:18 2010 for Opdis Disassembly Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
