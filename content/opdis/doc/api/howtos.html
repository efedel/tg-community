<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Opdis Disassembly Library: Howtos</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">


<h1><a class="anchor" id="howtos">Howtos </a></h1><p>Specific instructions on using features of <em>opdis</em> and <em>libopdis</em>. </p>
<p><a class="el" href="howtos.html#howto_cli">opdis</a></p>
<ul>
<li><a class="el" href="howtos.html#howto_cli_arch">Setting the target architecture</a></li>
<li><a class="el" href="howtos.html#howto_cli_disasm_opts">Setting disassembler options</a></li>
<li><a class="el" href="howtos.html#howto_cli_map">Mapping memory regions</a> </li>
</ul>
<p><a class="el" href="howtos.html#howto_app">libopdis API</a></p>
<ul>
<li><a class="el" href="howtos.html#howto_app_visited">Enabling visited-address tracking</a></li>
<li><a class="el" href="howtos.html#howto_app_display">Writing a display callback</a></li>
<li><a class="el" href="howtos.html#howto_app_handler">Writing a handler callback</a></li>
<li><a class="el" href="howtos.html#howto_app_resolver">Writing a resolver callback</a></li>
<li><a class="el" href="howtos.html#howto_app_decoder">Writing a decoder callback</a> </li>
</ul>
<hr/>
<h2><a class="anchor" id="howto_cli">
opdis</a></h2>
<h3><a class="anchor" id="howto_cli_arch">
Setting the target architecture</a></h3>
<p>The supported architectures can be displayed with the <b>--list-architectures</b> option: </p>
<div class="fragment"><pre class="fragment">bash$ opdis --list-architectures
        i386
        i386:x86-64
        i8086
        i386:intel
        i386:x86-64:intel
        l1om
        l1om:intel
        plugin
Default architecture is <span class="stringliteral">&apos;i386&apos;</span>
</pre></div><p> The architecture can then be passed to the <b>-a</b> option: </p>
<div class="fragment"><pre class="fragment">opdis -a i386:x86-64
</pre></div> <h3><a class="anchor" id="howto_cli_disasm_opts">
Setting disassembler options</a></h3>
<p>The available disassembler options for all supported architectures can be displayed with the <b>--list-disassembler-options</b> option: </p>
<div class="fragment"><pre class="fragment">bash$ /opdis --list-disassembler-options

The following i386/x86-64 specific disassembler options are supported <span class="keywordflow">for</span> use
with the -M <span class="keywordflow">switch</span> (multiple options should be separated by commas):
  x86-64      Disassemble in 64bit mode
  i386        Disassemble in 32bit mode
  i8086       Disassemble in 16bit mode
  att         Display instruction in AT&amp;T syntax
  intel       Display instruction in Intel syntax
  att-mnemonic
              Display instruction in AT&amp;T mnemonic
  intel-mnemonic
              Display instruction in Intel mnemonic
  addr64      Assume 64bit address size
  addr32      Assume 32bit address size
  addr16      Assume 16bit address size
  data32      Assume 32bit data size
  data16      Assume 16bit data size
  suffix      Always display instruction suffix in AT&amp;T syntax
</pre></div><p> The disassembler options can then be passed to the <b>-O</b> option, delimited by commas: </p>
<div class="fragment"><pre class="fragment">opdis -O <span class="stringliteral">&apos;intel,x86-64&apos;</span>
</pre></div> <dl class="note"><dt><b>Note:</b></dt><dd>The message about the <b>-M</b> switch is generated by <b>libopcodes</b> and should be ignored.</dd></dl>
<h3><a class="anchor" id="howto_cli_map">
Mapping memory regions</a></h3>
<p>The general format for specifying a memory map is: </p>
<div class="fragment"><pre class="fragment">[target]:offset@vma[+size]
</pre></div><p> The <b></b>:, <b>@</b>, and <b>+</b> characters are delimiters indicating that what follows is an offset, a vma, or a size, respectively. These components may appear in any order, but the <b>target</b> must always be first as it is not delimited. Note that these values are all parsed with strtoul, and so they may appear in any supported base (octal with a '0' prefix, decimal, or hexadecimal with a '0x' prefix). </p>
<p>The <b>target</b>, <b>size</b>, and <b>offset</b> components are all optional. The default value for <b>target</b> is 1, the ID of the first target. The default value for <b>offset</b> is 0. The default value for <b>size</b> is the size of the target. </p>
<p>Memory maps are generally used for the following purposes:</p>
<ul>
<li>to alter the VMA that appears in the disassembler output</li>
<li>to make multiple targets appear as a contiguous range of memory</li>
<li>to change the order in which targets appear in memory</li>
<li>to mimic the OS load addresses of the target(s) </li>
</ul>
<p><b>Examples</b> </p>
<p>Map the entirety of a.out to VMA 0x400000: </p>
<div class="fragment"><pre class="fragment">opdis -m @0x400000 --dry-run a.out
</pre></div><p>Map the entirety of a.out to VMA 0x400000 and the entirety of libc.so.6 to 0x7f626a934000: </p>
<div class="fragment"><pre class="fragment">opdis -m @0x400000 -m 2:0x7f626a934000 --dry-run a.out /usr/lib/libc.so.6
</pre></div><p>Map offset 0x1000 of a.out to VMA 0x401000: </p>
<div class="fragment"><pre class="fragment">opdis -m :0x1000@0x401000 --dry-run a.out
</pre></div><p>Map buffer 1 to 0x400000 and offset 0x1000 of a.out to VMA 0x401000: </p>
<div class="fragment"><pre class="fragment">opdis -m 1@400000 -m 2:0x1000@0x401000 -b <span class="stringliteral">&apos;7f 45 4c 46 02 01 01 00 00&apos;</span> --dry-run a.out
</pre></div><p>Make buffer 1 and buffer 2 contiguous in memory: </p>
<div class="fragment"><pre class="fragment">opdis -m 1@0 2@4 -b <span class="stringliteral">&apos;2e 2e 74 50&apos;</span> -b <span class="stringliteral">&apos;89 e1 31 d2&apos;</span> --dry-run
</pre></div><p>Make buffer 2 and buffer 1 contiguous in memory: </p>
<div class="fragment"><pre class="fragment">opdis -m 2@0 1@4 -b <span class="stringliteral">&apos;2e 2e 74 50&apos;</span> -b <span class="stringliteral">&apos;89 e1 31 d2&apos;</span> --dry-run
</pre></div><p>Use <b>ldd</b> to determine the load address of a shared library: </p>
<div class="fragment"><pre class="fragment">bash$ ldd a.out 
        linux-vdso.so.1 =&gt;  (0x00007fffc74cf000)
        libssl.so.0.9.8 =&gt; /lib/libssl.so.0.9.8 (0x00007f0340274000)
        libc.so.6 =&gt; /lib/libc.so.6 (0x00007f033ff05000)
        libcrypto.so.0.9.8 =&gt; /lib/libcrypto.so.0.9.8 (0x00007f033fb7e000)
        libdl.so.2 =&gt; /lib/libdl.so.2 (0x00007f033f97a000)
        libz.so.1 =&gt; /lib/libz.so.1 (0x00007f033f763000)
        /lib64/ld-linux-x86-64.so.2 (0x00007f03404c2000)
bash$ opdis -m 2@0x7f0340274000 --dry-run a.out /usr/lib/libssl.so
</pre></div><p>Use <b>readelf</b> to get the load address of the .text section for linear disassembly: </p>
<div class="fragment"><pre class="fragment">bash$ readelf a.out -S | grep -A 1 text
  [14] .text             PROGBITS         00000000004005d0  000005d0
       00000000000001f8  0000000000000000  AX       0     0     16
bash$ opdis -m :0x5d0@0x4005d0+0x1f8 -l @0x4005d0 a.out
</pre></div><p>Use <b>readelf</b> to get the executable program segment and program entry point for control-flow disassembly: </p>
<div class="fragment"><pre class="fragment">bash$ readelf a.out -l | grep -A 1 LOAD | grep -B 1 <span class="stringliteral">&apos;R E&apos;</span>
  LOAD           0x0000000000000000 0x0000000000400000 0x0000000000400000
                 0x000000000000087c 0x000000000000087c  R E    200000
bash$ readelf a.out -h | grep Entry
  Entry point address:               0x4005d0
bash$ opdis -m :@0x400000+0x87C -c @0x4005d0 a.out
</pre></div><h2><a class="anchor" id="howto_app">
libopdis API</a></h2>
<h3><a class="anchor" id="howto_app_visited">
Enabling visited-address tracking</a></h3>
<p>The default handler callback (<a class="el" href="group__configuration.html#ga3997e64314bfcffd7389ebbd0a667e4c">opdis_default_handler</a>) supports tracking of visited addresses. When the default handler encounters a VMA that has previously been disassembled, it halts disassembly and prevents the display callback from being invoked. This is useful for applications that write the instructions directly to output in their display callback. </p>
<p>Visited-address tracking is disabled by default in order to speed up disassembly, but it can be enabled by allocating an <a class="el" href="group__tree.html#ga25fa98bbacc954bc88721a8181140274">opdis_vma_tree_t</a> in the <a class="el" href="group__configuration.html#ga38db2ae554cc6fb7bc2f1467d4ae4c61">opdis_t</a> <b>visited_addr</b> field: </p>
<div class="fragment"><pre class="fragment">        o-&gt;visited_addr = <a class="code" href="group__tree.html#gacf3ae7b1e576bc22fe5d0500b6255103" title="Allocate an Address Tree.">opdis_vma_tree_init</a>();
</pre></div> <dl class="warning"><dt><b>Warning:</b></dt><dd>Visited-address tracking will slow disassembly down considerably. It is recommended that applications instead have their display callback store instructions in an <a class="el" href="group__tree.html#gaa9a9d27400c3b328fc91e68f513dcfa7">opdis_insn_tree_t</a> and write to output after disassembly has finished; this has the additional benefit of ordering the disassembled instructions by VMA. The display callback can be used in such cases to update a progress display.</dd></dl>
<h3><a class="anchor" id="howto_app_display">
Writing a display callback</a></h3>
<p>The display callback can be replaced with a function that takes an <a class="el" href="structopdis__insn__t.html">opdis_insn_t</a> and an optional argument parameter. The only restriction is that the callback <b>must</b> duplicate the <a class="el" href="structopdis__insn__t.html">opdis_insn_t</a> (using <a class="el" href="group__model.html#ga6c019dce7557b07130f039ffbbdfba0f">opdis_insn_dupe</a>) when storing it for later use. </p>
<p>This example adds an instruction to an <a class="el" href="group__tree.html#gaa9a9d27400c3b328fc91e68f513dcfa7">opdis_insn_tree_t</a> and prints a status message: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">static</span> <span class="keywordtype">void</span> my_display( <span class="keyword">const</span> <a class="code" href="structopdis__insn__t.html" title="Instruction object.">opdis_insn_t</a> * insn, <span class="keywordtype">void</span> * arg ) {
        <a class="code" href="structopdis__tree__base__t.html" title="The base of the tree.">opdis_insn_tree_t</a> tree = (<a class="code" href="structopdis__tree__base__t.html" title="The base of the tree.">opdis_insn_tree_t</a>) arg;
        <a class="code" href="structopdis__insn__t.html" title="Instruction object.">opdis_insn_t</a> * i = <a class="code" href="group__model.html#ga6c019dce7557b07130f039ffbbdfba0f" title="Duplicate an instruction object.">opdis_insn_dupe</a>( insn );

        <a class="code" href="group__tree.html#gaba70d76551d478f6ee815555f8e7d814" title="Insert an instruction into the tree.">opdis_insn_tree_add</a>( tree, i );

        printf( <span class="stringliteral">&quot;%d bytes at offset %X\n&quot;</span>, insn-&gt;<a class="code" href="structopdis__insn__t.html#a42c9030784c9712956c3104f75051aa7">size</a>, insn-&gt;<a class="code" href="structopdis__insn__t.html#a6660f8ece379eee21455538734ed45ff">offset</a> );
}
</pre></div><p> The following code demonstrates the use of this display callback: </p>
<div class="fragment"><pre class="fragment">        <span class="comment">/* allocate an insn tree which will free the insns when deleted */</span>
        <a class="code" href="structopdis__tree__base__t.html" title="The base of the tree.">opdis_insn_tree_t</a> tree = <a class="code" href="group__tree.html#gaf9663d376c0bba8f90ee0602d2733f27" title="Allocate an Instruction Tree.">opdis_insn_tree_init</a>( 1 );

        <a class="code" href="group__configuration.html#ga147b6b4a5cdf1c7613f9c5ab4613055a" title="Set the callback used to display or store disassembled instructions.">opdis_set_display</a>( opdis, my_display, (<span class="keywordtype">void</span> *) tree );
        <span class="comment">/* ... code to operate on tree, e.g. opdis_insn_tree_foreach ... */</span>

        <a class="code" href="group__tree.html#ga3871dfb18bb29c2bdf4d80456fc74a15" title="Free the instruction tree.">opdis_insn_tree_free</a>( tree );
</pre></div><h3><a class="anchor" id="howto_app_handler">
Writing a handler callback</a></h3>
<p>The handler callback is used to determine if disassembly should continue after the current instruction has been processed. </p>
<p>This example checks if a specific instruction mnemonic is encountered; if so, the handler displays the instruction and halts disassembly. The default handler is chained in order to halt on invalid instructions. </p>
<div class="fragment"><pre class="fragment"><span class="keyword">struct </span>HANDLER_ARG { <span class="keywordtype">char</span> halt_mnem[32]; <a class="code" href="structopdis__info__t.html" title="An opdis disassembler.">opdis_t</a> opdis; };

<span class="keyword">static</span> <span class="keywordtype">int</span> my_handler( <span class="keyword">const</span> <a class="code" href="structopdis__insn__t.html" title="Instruction object.">opdis_insn_t</a> * insn, <span class="keywordtype">void</span> * arg ) {
        <span class="keyword">struct </span>HANDLER_ARG * harg = (<span class="keyword">struct </span>HANDLER_ARG *) arg;

        <span class="comment">/* halt disassembly if specified mnemonic is encountered */</span>
        <span class="keywordflow">if</span> ( (insn-&gt;<a class="code" href="structopdis__insn__t.html#ac4eb3bb0e7228b5f67ee03a802dd5dc4">status</a> &amp; <a class="code" href="model_8h.html#ab6e80413ef7362ee18049556d5d0f16ba67197aafe6db7dc1cd618fa75b105a55">opdis_decode_mnem</a>) &amp;&amp; 
             ! strcmp(harg-&gt;halt_mnem, insn-&gt;<a class="code" href="structopdis__insn__t.html#a5af14a71fc2b6aab0ed70f510e50b8c1">mnemonic</a>) ) {

                <span class="comment">/* display instruction before halting */</span>
                harg-&gt;opdis-&gt;display( insn, harg-&gt;opdis-&gt;display_arg );
                <span class="keywordflow">return</span> 0;
        }

        <span class="comment">/* invoke default handler to check for invalid and visited addresses */</span>
        <span class="keywordflow">return</span> <a class="code" href="group__configuration.html#ga3997e64314bfcffd7389ebbd0a667e4c" title="The built-in opdis handler callback. The default handler returns true unless the...">opdis_default_handler</a>( insn, harg-&gt;opdis );
}
</pre></div><p> The following code demonstrates the use of this handler callback: </p>
<div class="fragment"><pre class="fragment">        <span class="keyword">struct </span>HANDLER_ARG handler_arg;
        strncpy( handler_arg.halt_mnem, <span class="stringliteral">&quot;ret&quot;</span>, 32 );
        handler_arg.opdis = o;
        <a class="code" href="group__configuration.html#ga1d33455d66bd8b6ab54e872536dbe36d" title="Set the callback used to determine whether to continue disassembly.">opdis_set_handler</a>( o, my_handler, (<span class="keywordtype">void</span> *) &amp;handler_arg );
</pre></div> <dl class="note"><dt><b>Note:</b></dt><dd>If the handler callback returns 0, the display callback will not be invoked for the current instruction. The handler must invoke the display callback itself if the instruction should be displayed before halting disassembly. </dd></dl>
<h3><a class="anchor" id="howto_app_resolver">
Writing a resolver callback</a></h3>
<p>The resolver callback is used to determine the VMA of the branch target of the current instruction. Applications that provide an emulator or VM will need to chain or replace this callback in order to resolve branch targets that are stored in registers or at a memory location. </p>
<p>This example assumes a flat address space and returns the <b>offset</b> component of an absolute address operand: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">static</span> <a class="code" href="group__types.html#ga840b1c720d75ade1aa951917191ab1f8">opdis_vma_t</a> my_resolver( <span class="keyword">const</span> <a class="code" href="structopdis__insn__t.html" title="Instruction object.">opdis_insn_t</a> * insn, <span class="keywordtype">void</span> * arg ) {

        <span class="comment">/* return the offset component of segment:offset operands */</span>
        <span class="keywordflow">if</span> ( (insn-&gt;<a class="code" href="structopdis__insn__t.html#ac4eb3bb0e7228b5f67ee03a802dd5dc4">status</a> &amp; <a class="code" href="model_8h.html#ab6e80413ef7362ee18049556d5d0f16ba1273a67fa19d4b2fccc843b3a8c7db48">opdis_decode_op_flags</a>) &amp;&amp;
             insn-&gt;<a class="code" href="structopdis__insn__t.html#a9ba1534b378c8f06e601a7630b589372">target</a> &amp;&amp; insn-&gt;<a class="code" href="structopdis__insn__t.html#a9ba1534b378c8f06e601a7630b589372">target</a>-&gt;<a class="code" href="structopdis__op__t.html#aaa0c4a07b16b6f09b4b47663f58e21a9">category</a> == <a class="code" href="metadata_8h.html#ga28daebb5c77a83733a8a25d048770729af6549aec4736930427d03a11d3ce85c1">opdis_op_cat_absolute</a> ) {
                <span class="keywordflow">return</span> (<a class="code" href="group__types.html#ga840b1c720d75ade1aa951917191ab1f8">opdis_vma_t</a>) insn-&gt;<a class="code" href="structopdis__insn__t.html#a9ba1534b378c8f06e601a7630b589372">target</a>-&gt;<a class="code" href="structopdis__op__t.html#ab3fe48d9a9a069b4c7d807b5c9219f5f">value</a>.<a class="code" href="structopdis__op__t.html#ac5179de4310092e584d8c34956f9b034">abs</a>.offset;
        }

        <span class="comment">/* invoke the default resolver to handle immediate values */</span>
        <span class="keywordflow">return</span> <a class="code" href="group__configuration.html#gac11d9479015d14921734cc165910e5a2" title="The built-in opdis resolver callback. This callback returns the immediate value of...">opdis_default_resolver</a>( insn, NULL );
}
</pre></div><p> The following code demonstrates the use of this resolver callback: </p>
<div class="fragment"><pre class="fragment">        <a class="code" href="group__configuration.html#ga07c4629ae65952da207df725d3b9446f" title="Set the callback used to obtain the buffer offset of a branch target.">opdis_set_resolver</a>( o, my_resolver, NULL );
</pre></div><h3><a class="anchor" id="howto_app_decoder">
Writing a decoder callback</a></h3>
<p>The decoder callback is used to generate an <a class="el" href="structopdis__insn__t.html">opdis_insn_t</a> from the list of strings emitted by <b>libopcodes</b>. An incomplete decoder callback (such as the default) will result in metadata not being generated for the instruction (including the list of operands). Control-flow disassembly relies on this metadata, making a functional decoder callback essential to most applications. </p>
<p>This example detects x86 control-flow instructions after invoking <a class="el" href="group__configuration.html#gab14a31bd82821fecdb9c6b1f38e73fa4">opdis_default_decoder</a> to do the basic instruction decoding. It does not chain either of the builtin x86 decoders, and no decoding is done for non-control-flow instructions. </p>
<div class="fragment"><pre class="fragment"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> * jcc_insns[] = {
        <span class="stringliteral">&quot;ja&quot;</span>, <span class="stringliteral">&quot;jae&quot;</span>, <span class="stringliteral">&quot;jb&quot;</span>, <span class="stringliteral">&quot;jbe&quot;</span>, <span class="stringliteral">&quot;jc&quot;</span>, <span class="stringliteral">&quot;jcxz&quot;</span>, <span class="stringliteral">&quot;jecxz&quot;</span>, 
        <span class="stringliteral">&quot;jrcxz&quot;</span>, <span class="stringliteral">&quot;je&quot;</span>, <span class="stringliteral">&quot;jg&quot;</span>, <span class="stringliteral">&quot;jge&quot;</span>, <span class="stringliteral">&quot;jl&quot;</span>, <span class="stringliteral">&quot;jle&quot;</span>, <span class="stringliteral">&quot;jna&quot;</span>, <span class="stringliteral">&quot;jnae&quot;</span>, <span class="stringliteral">&quot;jnb&quot;</span>, <span class="stringliteral">&quot;jnbe&quot;</span>,
        <span class="stringliteral">&quot;jnc&quot;</span>, <span class="stringliteral">&quot;jne&quot;</span>, <span class="stringliteral">&quot;jng&quot;</span>, <span class="stringliteral">&quot;jnge&quot;</span>, <span class="stringliteral">&quot;jnl&quot;</span>, <span class="stringliteral">&quot;jnle&quot;</span>, <span class="stringliteral">&quot;jno&quot;</span>, <span class="stringliteral">&quot;jnp&quot;</span>, <span class="stringliteral">&quot;jns&quot;</span>, <span class="stringliteral">&quot;jnz&quot;</span>,
        <span class="stringliteral">&quot;jo&quot;</span>, <span class="stringliteral">&quot;jp&quot;</span>, <span class="stringliteral">&quot;jpe&quot;</span>, <span class="stringliteral">&quot;js&quot;</span>, <span class="stringliteral">&quot;jz&quot;</span>
};

<span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> * call_insns[] = { <span class="stringliteral">&quot;lcall&quot;</span>, <span class="stringliteral">&quot;call&quot;</span>, <span class="stringliteral">&quot;callq&quot;</span> };

<span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> * jmp_insns[] = { <span class="stringliteral">&quot;jmp&quot;</span>, <span class="stringliteral">&quot;ljmp&quot;</span>, <span class="stringliteral">&quot;jmpq&quot;</span> };

<span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> * ret_insns[] = {
        <span class="stringliteral">&quot;ret&quot;</span>, <span class="stringliteral">&quot;lret&quot;</span>, <span class="stringliteral">&quot;retq&quot;</span>, <span class="stringliteral">&quot;retf&quot;</span>, <span class="stringliteral">&quot;iret&quot;</span>, <span class="stringliteral">&quot;iretd&quot;</span>, <span class="stringliteral">&quot;iretq&quot;</span>
};

<span class="keyword">static</span> <span class="keywordtype">void</span> handle_target( <a class="code" href="structopdis__insn__t.html" title="Instruction object.">opdis_insn_t</a> * out, <span class="keyword">const</span> <span class="keywordtype">char</span> * item ) {
        <a class="code" href="structopdis__op__t.html" title="Operand object.">opdis_op_t</a> * op = out-&gt;<a class="code" href="structopdis__insn__t.html#a73621016324fe3abdebb181608a18452">operands</a>[0];
        op-&gt;<a class="code" href="structopdis__op__t.html#aaa0c4a07b16b6f09b4b47663f58e21a9">category</a> = <a class="code" href="metadata_8h.html#ga28daebb5c77a83733a8a25d048770729abe08409f1ffa17c2195073a760056e07">opdis_op_cat_unknown</a>;
        op-&gt;<a class="code" href="structopdis__op__t.html#a151c51a89d62d2a649dc5573901cb635">flags</a> = <a class="code" href="metadata_8h.html#ga5ac390fb588453761de58abb3c0e268aa7d3130481f001b4160ab6858f0f6f1c2">opdis_op_flag_x</a>;
        <a class="code" href="group__model.html#gab02d492abf8059dbbd5083c4139e6712" title="Set the ascii field of an operand.">opdis_op_set_ascii</a>( op, item );
        out-&gt;<a class="code" href="structopdis__insn__t.html#a9ba1534b378c8f06e601a7630b589372">target</a> = out-&gt;<a class="code" href="structopdis__insn__t.html#a73621016324fe3abdebb181608a18452">operands</a>[0];
}

<span class="keyword">static</span> <span class="keywordtype">int</span> decode_mnemonic( <span class="keywordtype">char</span> ** items, <span class="keywordtype">int</span> idx, <a class="code" href="structopdis__insn__t.html" title="Instruction object.">opdis_insn_t</a> * out ) {
        <span class="keywordtype">int</span> i, num;
        <span class="keyword">const</span> <span class="keywordtype">char</span> *item = items[idx];

        <span class="comment">/* detect JMP */</span>
        num = (int) <span class="keyword">sizeof</span>(jmp_insns) / <span class="keyword">sizeof</span>(<span class="keywordtype">char</span> *);
        <span class="keywordflow">for</span> ( i = 0; i &lt; num; i++ ) {
                <span class="keywordflow">if</span> (! strcmp(jmp_insns[i], item) ) {
                        out-&gt;<a class="code" href="structopdis__insn__t.html#a5c37e29cfcd7b30eed1aae8aa9d5a9cd">category</a> = <a class="code" href="metadata_8h.html#ga01216fda1b5bcd2337106b78d6fa3411a8cdd463b0554f72c34f0293b200cc4a7">opdis_insn_cat_cflow</a>;
                        out-&gt;<a class="code" href="structopdis__insn__t.html#ae1604223cee03def2d186b0c0caf125b">flags</a>.<a class="code" href="structopdis__insn__t.html#a6fa9cdf01135176f6128e7e6eadeabb2">cflow</a> = <a class="code" href="metadata_8h.html#ga65b1d22eb012f92c4ea6cd4ec60a79c7ab7c7162b22ce85125c565256d3b02db1">opdis_cflow_flag_jmp</a>;
                        handle_target( out, items[idx+1] );
                        <span class="keywordflow">return</span> 1;
                }
        }

        <span class="comment">/* detect RET */</span>
        num = (int) <span class="keyword">sizeof</span>(ret_insns) / <span class="keyword">sizeof</span>(<span class="keywordtype">char</span> *);
        <span class="keywordflow">for</span> ( i = 0; i &lt; num; i++ ) {
                <span class="keywordflow">if</span> (! strcmp(ret_insns[i], item) ) {
                        out-&gt;<a class="code" href="structopdis__insn__t.html#a5c37e29cfcd7b30eed1aae8aa9d5a9cd">category</a> = <a class="code" href="metadata_8h.html#ga01216fda1b5bcd2337106b78d6fa3411a8cdd463b0554f72c34f0293b200cc4a7">opdis_insn_cat_cflow</a>;
                        out-&gt;<a class="code" href="structopdis__insn__t.html#ae1604223cee03def2d186b0c0caf125b">flags</a>.<a class="code" href="structopdis__insn__t.html#a6fa9cdf01135176f6128e7e6eadeabb2">cflow</a> = <a class="code" href="metadata_8h.html#ga65b1d22eb012f92c4ea6cd4ec60a79c7a79513228f151bb7ef3ec8683b139e501">opdis_cflow_flag_ret</a>;
                        <span class="keywordflow">return</span> 1;
                }
        }

        <span class="comment">/* detect branch (call/jcc) */</span>
        num = (int) <span class="keyword">sizeof</span>(call_insns) / <span class="keyword">sizeof</span>(<span class="keywordtype">char</span> *);
        <span class="keywordflow">for</span> ( i = 0; i &lt; num; i++ ) {
                <span class="keywordflow">if</span> (! strcmp(call_insns[i], item) ) {
                        out-&gt;<a class="code" href="structopdis__insn__t.html#a5c37e29cfcd7b30eed1aae8aa9d5a9cd">category</a> = <a class="code" href="metadata_8h.html#ga01216fda1b5bcd2337106b78d6fa3411a8cdd463b0554f72c34f0293b200cc4a7">opdis_insn_cat_cflow</a>;
                        out-&gt;<a class="code" href="structopdis__insn__t.html#ae1604223cee03def2d186b0c0caf125b">flags</a>.<a class="code" href="structopdis__insn__t.html#a6fa9cdf01135176f6128e7e6eadeabb2">cflow</a> = <a class="code" href="metadata_8h.html#ga65b1d22eb012f92c4ea6cd4ec60a79c7a7f6ce3512eeeb1f7ae31312093ec6d53">opdis_cflow_flag_call</a>;
                        handle_target( out, items[idx+1] );
                        <span class="keywordflow">return</span> 1;
                }
        }
        num = (int) <span class="keyword">sizeof</span>(jcc_insns) / <span class="keyword">sizeof</span>(<span class="keywordtype">char</span> *);
        <span class="keywordflow">for</span> ( i = 0; i &lt; num; i++ ) {
                <span class="keywordflow">if</span> (! strcmp(jcc_insns[i], item) ) {
                        out-&gt;<a class="code" href="structopdis__insn__t.html#a5c37e29cfcd7b30eed1aae8aa9d5a9cd">category</a> = <a class="code" href="metadata_8h.html#ga01216fda1b5bcd2337106b78d6fa3411a8cdd463b0554f72c34f0293b200cc4a7">opdis_insn_cat_cflow</a>;
                        out-&gt;<a class="code" href="structopdis__insn__t.html#ae1604223cee03def2d186b0c0caf125b">flags</a>.<a class="code" href="structopdis__insn__t.html#a6fa9cdf01135176f6128e7e6eadeabb2">cflow</a> = <a class="code" href="metadata_8h.html#ga65b1d22eb012f92c4ea6cd4ec60a79c7aee6601fc3faf9e82c9edf35ae04b2d7e">opdis_cflow_flag_jmpcc</a>;
                        handle_target( out, items[idx+1] );
                        <span class="keywordflow">return</span> 1;
                }
        }

        <span class="keywordflow">return</span> 0;
}

<span class="keyword">static</span> <span class="keywordtype">int</span> my_decoder( <span class="keyword">const</span> <a class="code" href="structopdis__insn__buffer__t.html" title="A buffer that stores the output of libopcodes before processing.">opdis_insn_buf_t</a> in, <a class="code" href="structopdis__insn__t.html" title="Instruction object.">opdis_insn_t</a> * out,
                       <span class="keyword">const</span> <a class="code" href="group__types.html#gaaf912ec32cb076f2f5b8f5d23176b386" title="A byte.">opdis_byte_t</a> * buf, <a class="code" href="types_8h.html#abd14f9464752cb16147541a663f70797" title="A buffer offset.">opdis_off_t</a> offset,
                       <a class="code" href="group__types.html#ga840b1c720d75ade1aa951917191ab1f8">opdis_vma_t</a> vma, <a class="code" href="types_8h.html#abd14f9464752cb16147541a663f70797" title="A buffer offset.">opdis_off_t</a> length, <span class="keywordtype">void</span> * arg ) {
        <span class="keywordtype">int</span> i, rv;

        <span class="comment">/* the default decoder fills ascii, vma, offset, size, and bytes.</span>
<span class="comment"> it sets status to opdis_decode_basic. */</span>
        rv = <a class="code" href="group__configuration.html#gab14a31bd82821fecdb9c6b1f38e73fa4" title="The built-in opdis instruction decoder This callback fills the ascii, offset, vma...">opdis_default_decoder</a>( in, out, buf, offset, vma, length, NULL );
        <span class="keywordflow">if</span> (! rv ) {
                <span class="keywordflow">return</span> rv;
        }

        <span class="keywordflow">for</span> ( i=0; i &lt; in-&gt;<a class="code" href="structopdis__insn__buffer__t.html#ac6ac8f5f9e20789db96292dc617fb308">item_count</a>; i++ ) {
                <span class="keywordflow">if</span> ( decode_mnemonic( in-&gt;<a class="code" href="structopdis__insn__buffer__t.html#aaf0fdbc70c318f7764adb62ba6ae8ba6">items</a>, i, out ) ) {
                        out-&gt;<a class="code" href="structopdis__insn__t.html#ac4eb3bb0e7228b5f67ee03a802dd5dc4">status</a> |= (<a class="code" href="model_8h.html#ab6e80413ef7362ee18049556d5d0f16ba67197aafe6db7dc1cd618fa75b105a55">opdis_decode_mnem</a> | <a class="code" href="model_8h.html#ab6e80413ef7362ee18049556d5d0f16bad195d5f09bba479fb9ab1da5932d3fcb">opdis_decode_ops</a> | 
                                        <a class="code" href="model_8h.html#ab6e80413ef7362ee18049556d5d0f16ba23da7e6f8a49aab0d74a8c82b0860a4a">opdis_decode_mnem_flags</a>);
                        <span class="keywordflow">break</span>;
                }
        }

        <span class="keywordflow">return</span> rv;
}
</pre></div><p> The following code demonstrates the use of this decoder callback: </p>
<div class="fragment"><pre class="fragment">        <a class="code" href="group__configuration.html#ga0b8981e6d86cbe9da620bd1d5c973b90" title="Set the callback used to build an opdis_insn_t from libopcodes data.">opdis_set_decoder</a>( o, my_decoder, NULL );
</pre></div> <dl class="note"><dt><b>Note:</b></dt><dd>While chaining of the default decoder (<a class="el" href="group__configuration.html#gab14a31bd82821fecdb9c6b1f38e73fa4">opdis_default_decoder</a>) is not required, it is strongly encouraged. The default decoder ensures that all instructions have their <b>status</b>, <b>ascii</b>, <b>vma</b>, <b>offset</b>, <b>size</b>, and <b>bytes</b> fields set reliably. </dd></dl>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Wed Mar 10 14:30:46 2010 for Opdis Disassembly Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
